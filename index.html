<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>El Reto del Diccionario</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6; /* Fondo gris claro */
            color: #1f2937;
        }
        .card {
            background-color: #ffffff;
            border-color: #e5e7eb;
        }
        .hide-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        .hide-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .rainbow-text {
            background: linear-gradient(45deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3);
            background-size: 400% 400%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: rainbow 2s ease-in-out infinite;
        }
        @keyframes rainbow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        .super-value-text {
            color: #ef4444; /* Rojo intenso */
            font-weight: bold;
        }
        #startupScreen, .modal-bg {
            background-color: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(4px);
        }
        
        .rainbow-border {
            border: 4px solid;
            border-image-slice: 1;
            border-image-source: linear-gradient(45deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3);
            animation: rainbow-border-animation 2s linear infinite;
        }
        @keyframes rainbow-border-animation {
            0% { border-image-source: linear-gradient(45deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3); }
            50% { border-image-source: linear-gradient(90deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3); }
            100% { border-image-source: linear-gradient(45deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3); }
        }
        .rainbow-bg-button {
            background: linear-gradient(to right, #8b5cf6, #d946ef, #ef4444, #f97316, #eab308, #84cc16, #22c55e, #14b8a6, #06b6d4, #3b82f6);
            background-size: 300% auto;
            animation: rainbow-bg-animation 4s linear infinite;
            color: white;
            border: none;
        }
        @keyframes rainbow-bg-animation {
            0% { background-position: 0% center; }
            50% { background-position: 100% center; }
            100% { background-position: 0% center; }
        }

        .glitch-wrapper {
            position: relative;
        }

        .glitch-text::before,
        .glitch-text::after {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #f3f4f6; 
            overflow: hidden;
            clip-path: inset(50% 50% 50% 50%);
        }

        .glitch-text::before {
            left: -2px;
            text-shadow: 2px 0 blue;
            animation: glitch-anim-2 1.5s infinite linear alternate-reverse;
        }

        .glitch-text::after {
            left: 2px;
            text-shadow: -2px 0 red;
            animation: glitch-anim-1 2s infinite linear alternate-reverse;
        }

        @keyframes glitch-anim-1 {
            0%, 100% { clip-path: inset(40% 0 61% 0); }
            25% { clip-path: inset(15% 0 75% 0); }
            50% { clip-path: inset(50% 0 45% 0); }
            75% { clip-path: inset(5% 0 85% 0); }
        }
        @keyframes glitch-anim-2 {
            0%, 100% { clip-path: inset(65% 0 30% 0); }
            25% { clip-path: inset(80% 0 15% 0); }
            50% { clip-path: inset(40% 0 50% 0); }
            75% { clip-path: inset(90% 0 5% 0); }
        }

        .flicker-anim {
            animation: flicker-animation 1s infinite;
        }

        @keyframes flicker-animation {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .limbo-glow {
            box-shadow: 0 0 12px 4px rgba(139, 92, 246, 0.7); /* Purple */
            animation: pulse-purple 2s infinite;
        }
        @keyframes pulse-purple {
            50% { box-shadow: 0 0 16px 6px rgba(139, 92, 246, 0.9); }
        }

        .boss-modal-bg {
            background-color: rgba(17, 24, 39, 0.9);
            backdrop-filter: blur(8px);
        }

        .christopher-modal-bg {
            background-color: rgba(224, 231, 255, 0.9);
            backdrop-filter: blur(8px);
        }

        .whisper-text {
            font-size: 1.5rem; /* Increased size */
            font-weight: 900; /* Bolder */
            color: #111827; /* Darker gray */
            animation: flicker-dark 2s infinite;
            text-align: center;
        }
        
        @keyframes flicker-dark {
            0%, 100% {
                text-shadow: 0 0 5px rgba(220, 38, 38, 0.4), 0 0 2px rgba(0,0,0,0.5);
                opacity: 0.8;
            }
            50% {
                text-shadow: 0 0 15px rgba(220, 38, 38, 0.8), 0 0 5px rgba(0,0,0,0.7);
                opacity: 1;
            }
        }

        .corrupted-text-effect {
            animation: flicker-dark 2s infinite;
            font-weight: bold;
        }
        
        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #f59e0b;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .bg-gradient-bronze { background-image: linear-gradient(to top right, #f3e9d2, #c6a49a); }
        .bg-gradient-plata { background-image: linear-gradient(to top right, #e0e0e0, #bdbdbd); }
        .bg-gradient-oro { background-image: linear-gradient(to top right, #fff176, #ffd54f); }
        .bg-gradient-platino { background-image: linear-gradient(to top right, #e0f7fa, #b2ebf2); }
        .bg-gradient-diamante { background-image: linear-gradient(to top right, #e1f5fe, #81d4fa); }
        .bg-gradient-maestro { background-image: linear-gradient(to top right, #f3e5f5, #e1bee7); }
        .bg-gradient-leyenda { background-image: linear-gradient(to top right, #ffebee, #ffcdd2); }
        
        /* Animación de vibración para input vacío */
        @keyframes shake {
          10%, 90% { transform: translate3d(-1px, 0, 0); }
          20%, 80% { transform: translate3d(2px, 0, 0); }
          30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
          40%, 60% { transform: translate3d(4px, 0, 0); }
        }
        .shake {
          animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
          transform: translate3d(0, 0, 0);
        }

    </style>
</head>
<body class="bg-gray-100 font-sans leading-normal tracking-normal min-h-screen">
    <!-- Pantalla de Inicio -->
    <div id="startupScreen" class="fixed inset-0 modal-bg flex flex-col items-center justify-center p-4 z-50 overflow-y-auto">
        <div class="text-center w-full max-w-4xl mx-auto">
            <h1 class="text-4xl sm:text-6xl font-black text-blue-900 mb-8">EL RETO DEL DICCIONARIO</h1>

            <div id="offlineView" class="flex flex-col items-center gap-4">
                <button id="playButton" class="w-full max-w-sm bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-8 rounded-lg transition duration-150 transform hover:scale-105 text-lg sm:text-xl">
                    Empezar Aventura
                </button>
            </div>
            
        </div>
        <p class="absolute bottom-4 text-xs text-gray-400 text-center">© 2025 El Reto del Diccionario | Desarrollado por Didac-Click Group.</p>
    </div>

    <!-- Modal para pedir Nombre -->
    <div id="nameInputModal" class="fixed inset-0 modal-bg hidden justify-center items-center p-4 z-[270]">
        <div class="bg-white p-6 max-w-sm w-full text-center rounded-xl shadow-lg border border-blue-300">
            <h3 class="text-xl font-bold text-gray-800 mb-4">¡Bienvenido, Héroe!</h3>
            <p class="text-gray-700 mb-4">Escribe tu nombre para la aventura:</p>
            <input id="playerNameInput" type="text" class="w-full mt-2 p-3 text-center text-lg font-semibold border-2 border-gray-300 rounded-lg focus:outline-none focus:border-blue-500" placeholder="Tu nombre...">
            <p id="nameError" class="text-red-500 text-sm mt-1 h-4"></p> <!-- Espacio para mensaje de error -->
            <button id="confirmNameButton" class="w-full mt-4 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-full">Confirmar</button>
        </div>
    </div>
    
    <!-- Game Container -->
    <div class="container mx-auto p-2 flex flex-col items-center min-h-screen">
        <div id="gameScreen" class="flex flex-col items-center w-full">
            <div class="flex flex-col lg:flex-row justify-center items-stretch w-full gap-4">
                
                <div id="playerMoneyCard" class="flex flex-col items-center justify-center flex-1 text-center border p-4 rounded-xl shadow-lg card transition-shadow duration-200">
                    <h2 class="text-xl font-bold text-green-700">Tu Riqueza</h2>
                    <p id="playerMoney" class="text-2xl sm:text-3xl font-extrabold text-green-800 mt-2">0</p>
                    <p class="text-sm text-gray-500 mt-1">
                        Ingreso Pasivo: <span id="passiveIncome" class="font-bold">0.0</span>/seg
                    </p>
                </div>

                <div id="currentWordCard" class="flex flex-col items-center flex-1 text-center border p-4 rounded-xl shadow-lg card transition-shadow duration-200">
                    <h3 class="text-xl font-bold mb-2">Palabra Actual</h3>
                    <p id="currentWord" class="text-3xl sm:text-5xl font-black mb-1">Cargando...</p>
                    <p id="wordCategory" class="text-md font-semibold text-gray-500 mb-1"></p>
                    <p id="wordValue" class="text-md font-extrabold text-blue-700"></p>
                    <div class="flex justify-center space-x-2 mt-2">
                        <button id="buyButton" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-full transition duration-150 transform hover:scale-105 text-sm">
                            Comprar
                        </button>
                    </div>
                    <div id="wordTimerBarContainer" class="w-full bg-gray-200 rounded-full h-2.5 mt-2">
                        <div id="wordTimerBar" class="h-2.5 rounded-full" style="width: 100%; transition: width 0.05s linear, background-color: 0.5s ease;"></div>
                    </div>
                </div>
            </div>

            <div class="flex flex-wrap lg:flex-nowrap w-full gap-4 mt-4 text-center border p-4 rounded-xl shadow-lg card">
                <div class="w-full">
                    <h2 class="text-xl font-bold text-gray-800 mb-4 text-center">Tu Colección de Palabras</h2>
                    <div id="inventoryContainer" class="flex flex-row overflow-x-auto whitespace-nowrap space-x-2 p-2">
                    </div>
                </div>
            </div>
            
            <div id="rulesContainer" class="w-full mt-4 text-center border p-4 rounded-xl shadow-lg hidden flex flex-col justify-center min-h-[110px] card">
                <div id="rulesDisplay" class="transition-opacity duration-200 ease-in-out">
                    <!-- Rules will be injected here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Barra de estado y botones del juego -->
    <div id="gameControls" class="fixed bottom-0 left-0 right-0 w-full flex flex-wrap justify-center items-center gap-4 p-3 bg-white border-t-2 border-gray-200 z-10">
        <div id="lifeCounterContainer" class="bg-white p-2 px-4 rounded-full shadow-lg border-2 border-gray-200 text-black font-extrabold text-lg flex-shrink-0 w-24 text-center transition-shadow duration-200">
            <span id="lifeCounter">3/3</span>
        </div>
        <button id="homeButton" class="bg-white hover:bg-gray-100 p-2 px-4 rounded-full shadow-lg border-2 border-gray-200 text-black font-extrabold text-lg transition duration-150 transform hover:scale-105 w-24 text-center">
            Inicio
        </button>
        <button id="muteButton" class="bg-white hover:bg-gray-100 p-2 rounded-full shadow-lg border-2 border-gray-200 w-12 h-12 flex items-center justify-center">
            <!-- SVG icon here -->
        </button>
    </div>

    <!-- Modal for Messages -->
    <div id="messageModal" class="fixed inset-0 modal-bg hidden justify-center items-center p-4 z-[250]">
        <div class="bg-white p-6 max-w-sm w-full text-center rounded-xl shadow-lg border border-blue-300">
            <p id="modalMessage" class="text-lg font-semibold text-gray-800 mb-4"></p>
            <button id="modalCloseButton" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-full">Cerrar</button>
        </div>
    </div>
    
    <!-- Modal for Confirmation -->
    <div id="confirmationModal" class="fixed inset-0 modal-bg hidden justify-center items-center p-4 z-[260]">
        <div class="bg-white p-6 max-w-sm w-full text-center rounded-xl shadow-lg border border-yellow-400">
            <p id="confirmationMessage" class="text-lg font-semibold text-gray-800 mb-4"></p>
            <div class="flex justify-center gap-4">
                <button id="confirmYesButton" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-6 rounded-full">Sí</button>
                <button id="confirmNoButton" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-6 rounded-full">No</button>
            </div>
        </div>
    </div>

    <!-- Modal for Word List -->
    <div id="wordsModal" class="fixed inset-0 modal-bg hidden justify-center items-center p-4 z-[200]">
        <div class="bg-white p-6 max-w-sm w-full text-center rounded-xl shadow-lg border border-gray-300">
            <h3 id="wordsModalTitle" class="text-xl font-bold text-gray-800 mb-4"></h3>
            <ul id="wordsList" class="max-h-64 overflow-y-auto text-left mb-4 px-2">
            </ul>
            <button id="wordsModalCloseButton" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-full">Cerrar</button>
        </div>
    </div>

    <!-- Modal for Mini-Challenge -->
    <div id="thiefMiniChallengeModal" class="fixed inset-0 boss-modal-bg hidden justify-center items-center p-4 z-[200]">
        <div class="bg-gray-800 p-8 max-w-md w-full text-center rounded-xl shadow-2xl border-4 border-red-500 text-white">
            <div id="thiefMiniChallengeIcon" class="w-12 h-12 mx-auto mb-3 text-red-500"></div>
            <h3 class="text-3xl font-extrabold text-red-500 mb-2">¡MINI-RETO!</h3>
            <p id="challengeDescription" class="text-md text-gray-300 mb-4"></p>
            <p id="challengeQuestion" class="text-4xl font-black mb-4 font-mono"></p>
            <p class="text-sm font-bold text-gray-400">Tiempo restante: <span id="challengeTimer" class="text-red-500">30</span>s</p>
            
            <div id="challengeInputContainer">
                 <input id="challengeInput" type="text" class="w-full mt-4 p-3 text-center text-lg font-semibold border-2 bg-gray-700 border-gray-600 rounded-lg focus:outline-none focus:border-red-500 text-white">
            </div>

            <div id="challengeButtonsContainer" class="hidden justify-center gap-4 mt-4">
                <button id="trueButton" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-6 rounded-lg">Verdadero</button>
                <button id="falseButton" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-6 rounded-lg">Falso</button>
            </div>
        </div>
    </div>

    <!-- Modal for Boss Challenge -->
    <div id="bossModal" class="fixed inset-0 boss-modal-bg flex justify-center items-center p-4 z-[200] hidden opacity-0 transition-opacity duration-200">
        <div id="bossModalContent" class="bg-gray-800 text-white p-8 max-w-2xl w-full text-center rounded-xl shadow-2xl border-4 border-red-700 transform transition-all duration-150 scale-95 opacity-0">
            <div id="bossIconContainer" class="w-16 h-16 mx-auto mb-4 text-red-500"></div>
            <h3 class="text-3xl font-extrabold text-red-500 mb-2">EL LADRÓN DE TILDES</h3>
            <p id="bossDialogue" class="text-md text-gray-300 mb-4 h-10"></p>
            <div id="bossChallengeContent" class="hidden">
                <p class="text-md text-gray-400 mb-2">Reescribe la oración con las tildes correctas:</p>
                <p id="bossChallengeSentence" class="text-2xl font-mono bg-gray-900 p-3 rounded-lg mb-4"></p>
                <p class="text-sm font-bold text-gray-400">Tiempo restante: <span id="bossTimer" class="text-red-500">60</span>s</p>
                <input id="bossChallengeInput" type="text" class="w-full mt-4 p-3 text-center text-lg font-semibold border-2 bg-gray-700 border-gray-600 rounded-lg focus:outline-none focus:border-red-500 text-white">
            </div>
        </div>
    </div>
    
    <!-- Modal de Susurro/Burla del Ladrón -->
    <div id="thiefWhisperModal" class="fixed inset-0 boss-modal-bg flex justify-center items-center p-4 z-[250] hidden opacity-0 transition-opacity duration-200">
        <div class="bg-gray-800 text-white p-8 max-w-md w-full text-center rounded-xl shadow-2xl border-2 border-red-700">
             <div id="thiefWhisperIcon" class="w-12 h-12 mx-auto mb-3 text-red-500"></div>
            <p id="thiefWhisperDialogue" class="text-gray-300 text-lg mb-4 italic h-10"></p>
            <!-- No close button needed, closes automatically -->
        </div>
    </div>

    <!-- Modal for Random Thief Attack -->
    <div id="randomThiefAttackModal" class="fixed inset-0 boss-modal-bg flex justify-center items-center p-4 z-[250] hidden opacity-0 transition-opacity duration-200">
        <div class="bg-gray-800 text-white p-8 max-w-md w-full text-center rounded-xl shadow-2xl border-2 border-red-700">
             <div id="randomThiefIcon" class="w-12 h-12 mx-auto mb-3 text-red-500"></div>
            <h4 class="text-xl font-bold text-red-400 mb-2">El Ladrón de Tildes ataca...</h4>
            <p id="randomThiefDialogue" class="text-gray-300 mb-4 italic h-10"></p>
            <div id="randomThiefEffect" class="hidden bg-gray-900 p-4 rounded-lg">
                <p id="randomThiefEffectText" class="text-lg font-bold text-gray-200"></p>
            </div>
             <!-- No close button needed, closes automatically -->
        </div>
    </div>

     <!-- Modal for Thief's Deal -->
    <div id="thiefDealModal" class="fixed inset-0 boss-modal-bg flex justify-center items-center p-4 z-[260] hidden opacity-0 transition-opacity duration-200">
        <div class="bg-gray-800 text-white p-8 max-w-md w-full text-center rounded-xl shadow-2xl border-2 border-red-700">
             <div id="thiefDealIcon" class="w-12 h-12 mx-auto mb-3 text-red-500"></div>
            <h4 class="text-xl font-bold text-red-400 mb-2">Un Trato Inesperado</h4>
            <p id="thiefDealDialogue" class="text-gray-300 mb-4 min-h-[4rem]"></p>
            <div id="thiefDealButtons" class="hidden justify-center gap-4 mt-6">
                <button id="acceptDealButton" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-6 rounded-lg">Aceptar Trato</button>
                <button id="rejectDealButton" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-6 rounded-lg">Rechazar</button>
            </div>
        </div>
    </div>

    <!-- Modal for Guardian of the Limbo -->
    <div id="guardianModal" class="fixed inset-0 christopher-modal-bg flex justify-center items-center p-4 z-[250] hidden opacity-0 transition-opacity duration-300">
        <div class="bg-white text-gray-800 p-8 max-w-2xl w-full text-center rounded-2xl shadow-2xl rainbow-border">
            <div id="guardianIcon" class="w-16 h-16 mx-auto mb-4 text-indigo-500">
                 <svg class="w-full h-full" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z" />
                </svg>
            </div>
            <h3 class="text-3xl font-extrabold text-indigo-700 mb-2"><span class="rainbow-text">Guardián del Limbo</span></h3>
            <p id="guardianDialogue" class="text-gray-600 mb-4 h-24 text-lg"></p>
            <div id="guardianButtons" class="hidden justify-center gap-4 mt-6">
                <button id="acceptGiftButton" class="rainbow-bg-button font-bold py-2 px-6 rounded-lg">Aceptar Don</button>
                <button id="rejectGiftButton" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg">Rechazar</button>
            </div>
        </div>
    </div>

    <!-- Modal for Guardian Gift -->
    <div id="guardianGiftModal" class="fixed inset-0 christopher-modal-bg flex justify-center items-center p-4 z-[250] hidden opacity-0 transition-opacity duration-300">
        <div class="bg-white text-gray-800 p-8 max-w-md w-full text-center rounded-2xl shadow-2xl rainbow-border">
            <div id="guardianGiftIcon" class="w-12 h-12 mx-auto mb-3 text-indigo-500">
                 <svg class="w-full h-full" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z" />
                </svg>
            </div>
            <h4 class="text-xl font-bold text-indigo-700 mb-2">Un Regalo del Guardián</h4>
            <p id="guardianGiftDialogue" class="text-gray-600 mb-4 h-10"></p>
            <div id="guardianGiftEffect" class="hidden bg-indigo-50 p-4 rounded-lg">
                <p id="guardianGiftEffectText" class="text-lg font-bold text-indigo-800"></p>
            </div>
            <!-- No close button needed, closes automatically -->
        </div>
    </div>


    <!-- Modal for Game Over -->
    <div id="gameOverScreen" class="fixed inset-0 bg-red-900/80 backdrop-blur-sm hidden flex flex-col justify-center items-center p-0 z-[300]">
        <div class="bg-red-800 text-white p-8 w-full h-full text-center flex flex-col justify-center items-center">
            <h2 class="text-5xl font-extrabold mb-4">GAME OVER</h2>
            <p id="gameOverMessage" class="text-lg mb-6"></p>
            <button id="backToGameFromGameOver" class="bg-white text-red-800 font-bold py-3 px-6 rounded-full transition duration-150 transform hover:scale-105">
                Volver a intentarlo
            </button>
        </div>
    </div>

    <!-- Pantalla de Victoria (Revisada) -->
    <div id="winScreen" class="fixed inset-0 bg-green-900/80 backdrop-blur-sm hidden flex flex-col justify-center items-center p-0 z-[300]">
        <div class="bg-green-700 text-white p-8 w-full h-full text-center flex flex-col justify-center items-center">
            <h2 class="text-5xl font-extrabold mb-4">¡HAS GANADO!</h2>
            <p id="winMessage" class="text-lg mb-6"></p> <!-- Contenido dinámico aquí -->
            <div class="flex flex-col sm:flex-row gap-4 mb-4">
                <button id="reiniciarButton" class="bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-6 rounded-full transition duration-150 transform hover:scale-105">
                    Reiniciar Juego
                </button>
            </div>
        </div>
    </div>
    
    <script type="module">
        let gameState = 'STARTUP'; 
        let playerName = ""; // Variable para guardar el nombre

        let playerMoney = 500;
        let playerWords = {};
        let usedChallengeWords = {};
        let currentWord = {};
        let passiveIncome = 0;
        let initialCredits = 500; 
        let consecutiveFailures = 0;
        let playerStats = {
            wordsBought: 0,
            challengesWon: 0,
            bossesDefeatedCount: 0,
        };
        
        let animationFrameId = null;
        let lastUpdateTime = 0;
        let timeSinceLastIncomeUpdate = 0;
        let wordDisplayTimeout;
        let challengeTimerInterval;
        let guardianBlessingTimeout = null; 
        let randomEventInterval = null; 
        
        let christopherBoostEndTime = 0;
        let superValueBoosts = {}; 
        let limboGramaticalEndTime = 0;
        let limboTriggeredThisLevel = false; 
        let dealRejectedForLimboBoost = false; 
        let hasHadFirstRandomAttackThisPartida = false;
        let confusionModeEndTime = 0; 
        let guardianBlessingAvailable = true; 

        let currentView = 'startup'; 
        let gameStarted = false;
        let hasBoughtFirstWord = false;
        let activeChallengeOnLoad = false;
        let visibilityChangeHandler = null;
        let confirmCallback = null;
        let currentChallengeData = {};
        
        let audioInitialized = false;
        let mainMusicLoop, thiefMusicLoop;
        let mainSynth, thiefSynth;
        let isMuted = false;

        let bossesDefeated = [], whisperInterval = null;
        const BOSS_MILESTONES = { 1: 50, 2: 100, 3: 150, 4: 200, 5: 250, 6: 300, 7: 350, 8: 400 };
        let currentBossLevel = 0, currentBossSentence = {};
        let bossTimerInterval;
        let isWhispering = false;
        let activeWhisper = "";
        let corruptedWordsBought = 0;
        
        const PRICE_PER_LETTER = 15;
        const SUPER_VALUE_MULTIPLIER = 2;
        const INFLATION_FACTOR = 100;
        const CHALLENGE_REWARDS = { base: 50000 };
        
        const CORRUPTED_WORDS = [
            { wrong: "Lapiz", right: "Lápiz", category: "Llanas" }, { wrong: "Arbol", right: "Árbol", category: "Llanas" },
            { wrong: "Cafe", right: "Café", category: "Agudas" }, { wrong: "Sofa", right: "Sofá", category: "Agudas" },
            { wrong: "Musica", right: "Música", category: "Esdrújulas" }, { wrong: "Pagina", right: "Página", category: "Esdrújulas" },
            { wrong: "Compas", right: "Compás", category: "Agudas" }, { wrong: "Dificil", right: "Difícil", category: "Llanas" },
            { wrong: "Celula", right: "Célula", category: "Esdrújulas" }, { wrong: "Jamas", right: "Jamás", category: "Agudas" }
        ];

        const TONIC_SYLLABLE_WORDS = [
             { word: "cantar", syllable: "tar" }, { word: "papel", syllable: "pel" },
             { word: "ciudad", syllable: "dad" }, { word: "reloj", syllable: "loj" },
             { word: "feliz", syllable: "liz" }, { word: "amor", syllable: "mor" },
             { word: "mesa", syllable: "me" }, { word: "libro", syllable: "li" },
             { word: "ventana", syllable: "ta" }, { word: "casa", syllable: "ca" },
             { word: "lunes", syllable: "lu" }, { word: "calle", syllable: "ca" },
             { word: "joven", syllable: "jo" }, { word: "examen", syllable: "xa" } // Ojo con esta
        ];
        const MINI_CHALLENGE_WORDS = {
            accent: [ 
                 {wrong: "logica", right: "lógica"}, {wrong: "arabe", right: "árabe"},
                 {wrong: "video", right: "vídeo"}, {wrong: "camion", right: "camión"},
                 {wrong: "carcel", right: "cárcel"}, {wrong: "exito", right: "éxito"},
                 {wrong: "jamas", right: "jamás"}, {wrong: "ultimo", right: "último"},
                 {wrong: "album", right: "álbum"}, {wrong: "cesped", right: "césped"},
                 {wrong: "facil", right: "fácil"}, {wrong: "angel", right: "ángel"},
                 {wrong: "mastil", right: "mástil"}, {wrong: "util", right: "útil"},
                 {wrong: "tambien", right: "también"}, {wrong: "despues", right: "después"},
                 {wrong: "corazon", right: "corazón"}, {wrong: "bebe", right: "bebé"},
                 {wrong: "pagina", right: "página"}, {wrong: "musica", right: "música"},
                 {wrong: "telefono", right: "teléfono"}, {wrong: "brujula", right: "brújula"}
            ],
            trueFalse: [ 
                { word: "Reloj", category: "Agudas", isCorrect: true },
                { word: "Casa", category: "Agudas", isCorrect: false },
                { word: "Fácil", category: "Llanas", isCorrect: true },
                { word: "Libro", category: "Esdrújulas", isCorrect: false },
                { word: "Pájaro", category: "Esdrújulas", isCorrect: true },
                { word: "Resolver", category: "Llanas", isCorrect: false },
                { word: "Cantar", category: "Agudas", isCorrect: true },
                { word: "Lámpara", category: "Llanas", isCorrect: false },
                 { word: "Cárcel", category: "Agudas", isCorrect: false },
                 { word: "Azúcar", category: "Llanas", isCorrect: true },
                 { word: "Árbol", category: "Esdrújulas", isCorrect: false },
                 { word: "Teléfono", category: "Esdrújulas", isCorrect: true },
                 { word: "Camión", category: "Llanas", isCorrect: false }
            ]
        };
        
        const BOSS_INITIAL_DIALOGUES = [
            "Veo que has reunido un pequeño tesoro... Demuéstrame que mereces conservarlo.", "Tus palabras acumuladas cantan una melodía que me atrae. ¿Defenderás tu colección?",
            "Huelo el poder de la sintaxis en ti. Pero, ¿conoces la verdadera ortografía?", "Has sido descuidado. Dejaste un rastro de tildes olvidadas, y yo lo he seguido hasta aquí.",
            "Otro coleccionista... Creen que acumular es saber. Te enseñaré la diferencia.", "Las reglas son mis cadenas y tu conocimiento, la llave. No te la dejaré usar.",
            "¿Sientes ese peso en el aire? Son las tildes que has ignorado. Vengo a reclamarlas.", "Tus avances no han pasado desapercebidos. Es hora de una pequeña corrección.",
            "Me llaman ladrón, pero yo me considero un purista. Vengo a limpiar tu colección de errores.", "El conocimiento sin precisión es ruido. Y tú estás haciendo mucho ruido."
        ];
        const BOSS_VICTORY_DIALOGUES = [
            "Impresionante... Por ahora, tu conocimiento es tuyo. Pero volveré a sentir tu poder.", "Has demostrado tu valía, mortal. Disfruta de tu tesoro... mientras puedas.",
            "Me has vencido, sí. Pero recuerda que una sola tilde olvidada puede deshacerlo todo.", "Tu mente es aguda. Una herramienta peligrosa en las manos adecuadas. Hasta la próxima.",
            "Admito mi derrota. La precisión de tus tildes es un arma formidable."
        ];
        const BOSS_DEFEAT_DIALOGUES = [
            "Tu ignorancia es... deliciosa. Estas palabras estarán mejor conmigo.", "Tal como lo esperaba. Un simple acumulador sin verdadero conocimiento. Gracias por el tributo.",
            "Te falta práctica. Vuelve cuando sepas la diferencia entre un 'si' y un 'sí'.", "Un error tan simple... y tan costoso. Tus palabras ahora me pertenecen.",
            "La duda es el óxido del intelecto. Y el tuyo está completamente corroído."
        ];
        
        const BOSS_TAUNT = "JA JA JA JA";

        const BOSS_SENTENCES = {
            1: [ 
                { wrong: "El habil mecanico arreglo el automovil rapido.", right: "El hábil mecánico arregló el automóvil rápido." },
                { wrong: "La musica clasica es mi pasion.", right: "La música clásica es mi pasión." },
                { wrong: "El examen de matematicas fue dificil.", right: "El examen de matemáticas fue difícil." },
                { wrong: "Te gustaria tomar un te caliente.", right: "Te gustaría tomar un té caliente." },
                { wrong: "El libro es para el.", right: "El libro es para él." }
            ],
            2: [ 
                { wrong: "Tu no sabes si el quiere te o cafe.", right: "Tú no sabes si él quiere té o café." },
                { wrong: "Se que tu tienes mi libro, pero el no lo sabe.", right: "Sé que tú tienes mi libro, pero él no lo sabe." },
                { wrong: "De mas de lo que el te pide.", right: "Dé más de lo que él te pide." },
                { wrong: "Aun no he terminado, aun cuando todos se han ido.", right: "Aún no he terminado, aun cuando todos se han ido." },
                { wrong: "A mi me gusta mas el te que a el.", right: "A mí me gusta más el té que a él." }
            ],
            3: [ 
                { wrong: "Dime que necesitas y cuando lo quieres para saber como ayudarte.", right: "Dime qué necesitas y cuándo lo quieres para saber cómo ayudarte." },
                { wrong: "Quien te dijo que y como lo supiste es un misterio.", right: "Quién te dijo qué y cómo lo supiste es un misterio." },
                { wrong: "No entiendo por que ries, ni cual es el motivo.", right: "No entiendo por qué ríes, ni cuál es el motivo." },
                { wrong: "Donde esta el libro del que te hable cuando te vi.", right: "Dónde está el libro del que te hablé cuando te vi." },
                { wrong: "Que sorpresa verte aqui! Cuando llegaste?", right: "¡Qué sorpresa verte aquí! ¿Cuándo llegaste?" }
            ],
            4: [ 
                { wrong: "El buho volaba silenciosamente sobre el maiz.", right: "El búho volaba silenciosamente sobre el maíz." },
                { wrong: "Raul leia poesia en el baul antiguo.", right: "Raúl leía poesía en el baúl antiguo." },
                { wrong: "Actua con cortesia y rapidamente.", right: "Actúa con cortesía y rápidamente." },
                { wrong: "Fisicamente, se sentia debil despues del frio.", right: "Físicamente, se sentía débil después del frío." },
                { wrong: "Cuentamelo rapidamente, no tengo mucho tiempo.", right: "Cuéntamelo rápidamente, no tengo mucho tiempo." }
            ],
            5: [ 
                { wrong: "Es un analisis fisico-quimico complejo.", right: "Es un análisis físico-químico complejo." },
                { wrong: "El tio vivo funcionaba mecanicamente.", right: "El tiovivo funcionaba mecánicamente." },
                { wrong: "Dificilmente encontraras un especimen asi.", right: "Difícilmente encontrarás un espécimen así." },
                { wrong: "Pideme lo que quieras, dámelo ahora.", right: "Pídeme lo que quieras, dámelo ahora." },
                { wrong: "El menu incluia cócteles y sándwiches.", right: "El menú incluía cócteles y sándwiches." }
            ],
            6: [ 
                { wrong: "Aun no se por que lo hizo.", right: "Aún no sé por qué lo hizo." },
                { wrong: "El te que te di es para mi.", right: "El té que te di es para mí." },
                { wrong: "Solo se que tu iras solo.", right: "Solo sé que tú irás solo." },
                { wrong: "El camion que viste es de el.", right: "El camión que viste es de él." },
                { wrong: "No le de mas de lo que pidio.", right: "No le dé más de lo que pidió." }
            ],
            7: [ 
                { wrong: "Actuo cortesmente y se fue rapidamente.", right: "Actuó cortésmente y se fue rápidamente." },
                { wrong: "Raul veia como caia la nieve.", right: "Raúl veía cómo caía la nieve." },
                { wrong: "El maiz y la raiz crecieron.", right: "El maíz y la raíz crecieron." },
                { wrong: "Fue un acto heroico y tragico.", right: "Fue un acto heroico y trágico." },
                { wrong: "Comio agilmente y se durmio.", right: "Comió ágilmente y se durmió." }
            ],
            8: [ 
                { wrong: "Dime que quieres, cuanto cuesta y donde esta.", right: "Dime qué quieres, cuánto cuesta y dónde está." },
                { wrong: "Se que tu no tienes fe en el.", right: "Sé que tú no tienes fe en él." },
                { wrong: "El vehiculo dio un giro brusco.", right: "El vehículo dio un giro brusco." },
                { wrong: "Aun los que no sabian, lo hicieron.", right: "Aun los que no sabían, lo hicieron." },
                { wrong: "El oceano Pacifico es mas grande.", right: "El océano Pacífico es más grande." }
            ]
        };
        
        const ICON_LIBRARY = {
            'bossIcon': `<svg class="w-full h-full" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7z"></path><circle cx="12" cy="12" r="3"></circle><path d="M10.5 14.5c.5.3 1.2.3 1.7 0 M8 9.5s1-1 4-1 4 1 4 1"/></svg>`,
            'christopherIcon': `<svg class="w-full h-full" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z" /></svg>`,
            'speakerOn': `<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" /></svg>`,
            'speakerOff': `<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" clip-rule="evenodd" /><path stroke-linecap="round" stroke-linejoin="round" d="M17 14l-2-2m0 0l-2-2m2 2l2-2m-2 2l-2 2" /></svg>`
        };
        
        // Base de datos de palabras con correcciones
        const HUGE_WORD_DATABASE = {
             "Monosílabos": {
                value: 10,
                words: ["Sol", "Mar", "Luz", "Voz", "Pan", "Sal", "Miel", "Tren", "Flor", "Rey", "Son", "Paz", "Bien", "Mal", "Gas", "No", "Sí", "Yo", "Él", "Tú", "Ve", "Da", "Sé", "Vi", "Di", "Pie", "Fe", "Ley", "Don", "Fin", "Mes", "Mil", "Res", "Ron", "Set", "Sur", "Tal", "Tez", "Zas", "Dar", "Ver", "Mas", "Te", "Mi", "Si", "El", "Un", "La", "Los", "Las", "Dos", "Tres", "Cien", "Tan", "Muy", "Ah", "Oh", "Ya", "En", "Es", "Ir", "O", "Y", "A", "De", "Ni", "So", "Va", "Le", "Lo", "Me", "Se", "Su", "Tu", "Gol", "Bar", "Bit", "Box", "Bus", "Chip", "Club", "Fan", "Fax", "Gel", "Gin", "Golf", "Jet", "Kit", "Led", "Link", "Look", "Pub", "Punk", "Rap", "Rock", "Rol", "Show", "Ski", "Snob", "Spot", "Stop", "Surf", "Test", "Top", "Tour", "Web", "Zen", "Zinc", "Clip", "Crack", "Cross", "Film", "Flash", "Folk", "Full"], 
                superValueWords: ["Flor", "Voz", "Rey", "Paz", "Luz", "Miel"],
                limit: 100 
            },
            "Agudas": {
                value: 100,
                 words: ["Acción", "Adicción", "Además", "Andén", "Balón", "Bebé", "Café", "Camión", "Canción", "Colibrí", "Corazón", "Después", "Emoción", "Interés", "Jabalí", "Jamás", "Jardín", "Jazmín", "Menú", "País", "París", "Pasión", "Perfección", "Portugués", "Revolución", "Sofá", "Solución", "También", "Visión", "Volcán", "Comió", "Estudió", "Habló", "Vivió", "Ganará", "Común", "Betún", "Calzón", "Dragón", "Francés", "Inglés", "Japonés", "Maní", "Ratón", "Tiburón", "Vudú", "Bambú", "Jabón", "Melón", "Patín", "Avión", "Botón", "Compás", "Decisión", "Estación", "Explosión", "Ilusión", "León", "Misión", "Opinión", "Pantalón", "Salmón", "Televisión", "Unión", "Violín", "Atún", "Azafrán", "Carbón", "Colchón", "Limón", "Salón", "Sartén", "Tapón", "Tazón", "Almacén", "Alquitrán", "Arnés", "Autobús", "Bailarín", "Bergantín", "Bombón", "Calderón", "Capitán", "Chapuzón", "Ciprés", "Civilización", "Composición", "Confirmación", "Congestión", "Construcción", "Conversación", "Corrupción", "Cotización", "División", "Edredón", "Evaluación", "Expedición", "Explicación", "Faraón", "Huracán", "Información", "Instalación", "Afganistán", 
                 "Cristal", "Cuartel", "Feliz", "Reloj", "Pared", "Cantar", "Comer", "Vivir"],
                superValueWords: ["Colibrí", "Jazmín", "Pasión", "Revolución", "Corazón", "Tiburón"],
                limit: 100 
            },
            "Llanas": {
                value: 250,
                 // Palabras Esdrújulas eliminadas de esta lista
                 words: ["Árbol", "Ángel", "Azúcar", "Cáncer", "Cárcel", "Carácter", "Césped", "Clímax", "Cráter", "Día", "Difícil", "Dólar", "Éter", "Fácil", "Fósil", "Fútbol", "Huésped", "Lápiz", "Líder", "Mártir", "Móvil", "Nácar", "Poesía", "Póker", "Río", "Tórax", "Trébol", "Túnel", "Geografía", "Biología", "Filosofía", "Tecnología", "Psicología", "Economía", "Anatomía", "Sandía", "Policía", "Cómics", "Fénix", "Hábil", "Inmóvil", "Referí", "Tándem", "Tótem", "Versátil", "Zombis", "Álbum", "Cáliz", "Débil", "Frágil", "Níquel", "Récord", "Estéril", "Portátil", "Táctil", "Textil", "Útil", "Automóvil", "Cónsul", "Dúctil", "Huérfano", "Mármol", "Néctar", "Péndulo", "Revólver", "Volátil", "Bíceps", "Fórceps", "Tríceps", "Acné", "Apóstol", "Cráneo", "Gómez", "López", "Martínez", "Pérez", "Sánchez", "Alcázar", "Bolívar", "Cádiz", "Héctor", "Júnior", "Suárez", "Tóner", "Wáter", "Ámbar", "Béisbol", "Cadáver", "Contraseña", "Cristóbal", "Estándar", "Flúor", "Gánster", "Hámster", "Ítem", "Kárdex", "Láser", "Máster", "Médium", "Póster", "Referéndum", "Sándwich", "Superávit"], 
                superValueWords: ["Carácter", "Cráter", "Poesía", "Geografía", "Fénix", "Filosofía"],
                limit: 100 
            },
            "Esdrújulas": {
                value: 500,
                 // Palabras movidas desde Llanas añadidas aquí
                words: ["Análisis", "Antártida", "Atmósfera", "Bolígrafo", "Brújula", "Cálculo", "Catástrofe", "Círculo", "Clínica", "Cómpralo", "Déficit", "Esdrújula", "Estómago", "Éxito", "Fábrica", "Fósforo", "Gramática", "Hígado", "Héroe", "Hipócrita", "Índice", "Lágrima", "Lógico", "Mágico", "Máquina", "Matemáticas", "Médico", "Miércoles", "Murciélago", "Músculo", "Música", "Número", "Oxígeno", "Página", "Pájaro", "Plátano", "Público", "Química", "Rápido", "Sábado", "Semáforo", "Sílaba", "Teléfono", "Término", "Tráfico", "Último", "Vértebra", "Víctima", "Aéreo", "Célula", "Diálogo", "Época", "Gótico", "Jurásico", "Kilómetro", "Óptimo", "Párrafo", "Pirámide", "Sátira", "Técnica", "Vándalo", "Académico", "Ábaco", "Águila", "Álgebra", "Ámbito", "Análogo", "Ánimo", "Antídoto", "Apóstrofe", "Armónica", "Arácnido", "Artículo", "Atlético", "Aurícula", "Auténtico", "Bálsamo", "Bárbaro", "Básico", "Benéfico", "Biblioteca", "Bólido", "Botánico", "Bóveda", "Bulímico", "Burócrata", "Cámara", "Capítulo", "Cápsula", "Cátedra", "Católico", "Centímetro", "Cerámica", "Cíclope", "Científico", "Clásico", "Código", "Colérico", "Cómico", "Cómplice", "Cónyuge", "Crédito", "Crítico", "Crónica", "Cúbico", "Cúpula", "Débito", "Década", "Décimo", "Demócrata", "Depósito", "Diámetro", "Didáctico", "Dinámico", "Cuádriceps", "Dátiles", "Énfasis", "Cónclave", "Dóberman", "Mánager", "Taxímetro"], 
                superValueWords: ["Atmósfera", "Murciélago", "Científico", "Matemáticas", "Pirámide", "Jurásico"],
                limit: 100 
            },
            "Sobreesdrújulas": {
                value: 1000000,
                words: ["Agradéceselo", "Apréndetelo", "Averíguamelo", "Búscaselo", "Comprándomelo", "Dígamelo", "Díceselo", "Enciéndemelo", "Entrégaselo", "Explícaselo", "Guárdaselo", "Hágaselo", "Júraselo", "Llévaselo", "Pídemelo", "Pásaselo", "Repíteselo", "Tráigaselo", "Véndeselo", "Dedicándoselo", "Estudiándotelo", "Explicándoselo", "Repitiéndoselo", "Comiéndoselo", "Escribiéndotelo", "Mirándoselo", "Preparándomelo", "Comprándoselo", "Llamándoselo", "Encontrándoselo", "Recibiéndoselo", "Entregándoselo", "Aceptándoselo", "Aconsejándoselo", "Acompañándotelo", "Aprendiéndotelo", "Bendiciéndotelo", "Buscándoselo", "Celebrándoselo", "Comentándoselo"],
                superValueWords: [],
                limit: 1 // Sin cambios
            }
        };

        let WORD_DATABASE = {}; 

        const categoryColors = { "Monosílabos": "text-gray-800", "Agudas": "text-green-800", "Llanas": "text-yellow-800", "Esdrújulas": "text-blue-800", "Sobreesdrújulas": "text-purple-800" };
        const categoryBackgrounds = { "Monosílabos": "bg-gray-200", "Agudas": "bg-green-200", "Llanas": "bg-yellow-200", "Esdrújulas": "bg-blue-200", "Sobreesdrújulas": "bg-purple-200" };
        
        function generatePlaythroughWordDatabase() {
            WORD_DATABASE = {};
            for (const category in HUGE_WORD_DATABASE) {
                const baseCategory = HUGE_WORD_DATABASE[category];
                // Copiar palabras para asegurar que no se modifique la constante original
                const wordsForThisGame = [...baseCategory.words]; 
                WORD_DATABASE[category] = { ...baseCategory, words: wordsForThisGame };
            }
            console.log("Playthrough word database generated:", WORD_DATABASE); // Log de depuración
        }


        function getFormattedDateTime() {
            const now = new Date();
            const date = now.toLocaleDateString('es-ES', { day: '2-digit', month: '2-digit', year: 'numeric' });
            const time = now.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' });
            return { date, time };
        }

        function recalculatePassiveIncome() {
            passiveIncome = 0;
            const now = Date.now();
            Object.keys(playerWords).forEach(category => {
                if (playerWords[category] && WORD_DATABASE[category] && category !== "Sobreesdrújulas") {
                    const count = playerWords[category].count || 0;
                    const baseValue = WORD_DATABASE[category].value; 
                    let categoryIncome = count * baseValue;
                    if (superValueBoosts[category] && now < superValueBoosts[category]) categoryIncome *= SUPER_VALUE_MULTIPLIER;
                    passiveIncome += categoryIncome;
                }
            });
        }
        
        function resetGameData() {
            initialCredits = 500; 
            playerMoney = initialCredits;
            passiveIncome = 0;
            usedChallengeWords = {};
            christopherBoostEndTime = 0;
            superValueBoosts = {};
            limboGramaticalEndTime = 0;
            hasBoughtFirstWord = false;
            limboTriggeredThisLevel = false; 
            dealRejectedForLimboBoost = false;
            bossesDefeated = [];
            corruptedWordsBought = 0;
            hasHadFirstRandomAttackThisPartida = false;
            confusionModeEndTime = 0;
            guardianBlessingAvailable = true; 
            if (guardianBlessingTimeout) clearTimeout(guardianBlessingTimeout); 
            guardianBlessingTimeout = null;
            playerStats = { wordsBought: 0, challengesWon: 0, bossesDefeatedCount: 0 }; 
            generatePlaythroughWordDatabase(); 
             // Asegurarse de inicializar playerWords después de generar la base de datos
            Object.keys(WORD_DATABASE).forEach(category => {
                 playerWords[category] = { count: 0, list: [] };
             });
        }
        
        function resetProgressButKeepLives() {
            passiveIncome = 0;
            Object.keys(playerWords).forEach(category => {
                if (playerWords[category]) {
                    playerWords[category].count = 0;
                    playerWords[category].list = [];
                }
            });
            // Recalcular el ingreso pasivo a 0 y actualizar UI
            recalculatePassiveIncome();
            updateUI();
        }
        
        function initializeGameState() {
             playerMoney = 500; 
             playerWords = {}; // Se inicializa vacío, resetGameData lo llenará
             usedChallengeWords = {}; 
             consecutiveFailures = 0; 
             bossesDefeated = []; 
             hasBoughtFirstWord = false; 
             isWhispering = false; 
             activeWhisper = ""; 
             corruptedWordsBought = 0;
             hasHadFirstRandomAttackThisPartida = false; 
             confusionModeEndTime = 0; 
             dealRejectedForLimboBoost = false;
             limboTriggeredThisLevel = false; 
             guardianBlessingAvailable = true; 
             if (guardianBlessingTimeout) clearTimeout(guardianBlessingTimeout); 
             guardianBlessingTimeout = null;
             playerStats = { wordsBought: 0, challengesWon: 0, bossesDefeatedCount: 0 }; 
             resetGameData(); // Llama a resetGameData para llenar playerWords y generar DB
        }

        function setGameState(newState) {
            if (gameState === newState) return; 
            
            const oldState = gameState;
            gameState = newState;
             console.log(`Game State Changed: ${oldState} -> ${newState}`); // Log de depuración

            if (newState !== 'PLAYING') {
                stopGameLoops();
            }
            
            switch (newState) {
                case 'PLAYING':
                    if (oldState !== 'CINEMATIC') {
                        hideAllModals(); 
                    }
                    startGameLoops();
                    playMainMusic(); 
                    if (oldState !== 'CINEMATIC') {
                        // Solo generar si no venimos de una cinemática que ya tenía una palabra
                        if (!currentWord || !currentWord.word) {
                             console.log("Generating initial word because currentWord is empty."); // Log de depuración
                             generateNewWord(true); 
                        } else {
                            console.log("Resuming with current word:", currentWord.word); // Log de depuración
                             // Si ya hay una palabra (ej: volvimos de un modal), actualizar su timer
                             updateTimerBarUI();
                             const elapsedTime = Date.now() - (currentWord.startTime || Date.now());
                             const duration = currentWord.isBonus ? 1000 : 3000;
                             const remainingTime = Math.max(0, duration - elapsedTime);
                             startWordDisplayTimer(remainingTime);
                        }
                    } else {
                         // Si volvemos de cinemática, reanudar timer de la palabra actual
                        if (currentWord && currentWord.startTime) {
                            const elapsedTime = Date.now() - currentWord.startTime;
                            const duration = currentWord.isBonus ? 1000 : 3000;
                            const remainingTime = Math.max(0, duration - elapsedTime);
                            console.log(`Resuming word timer after cinematic. Remaining: ${remainingTime}ms`); // Log de depuración
                            startWordDisplayTimer(remainingTime);
                        } else {
                             console.log("Generating new word after cinematic because currentWord lacks startTime."); // Log de depuración
                             generateNewWord(true); // Generar nueva si no había timer
                        }
                    }
                    break;
                case 'STARTUP':
                    hideAllModals();
                    playMainMusic(); 
                    break;
                case 'CINEMATIC':
                case 'CHALLENGE_MINI':
                case 'CHALLENGE_BOSS':
                    // La música se gestiona en las funciones que llaman a estos estados
                    break; 
                case 'GAME_OVER':
                case 'GAME_WON':
                    stopAllMusic(); // Detener toda la música al final
                    break;
            }
        }

        function showModal(message, duration = 2500, isSuccess = true) {
            const modal = document.getElementById('messageModal');
            const closeButton = document.getElementById('modalCloseButton');
            const messageModalContent = messageModal.querySelector('div');
            document.getElementById('modalMessage').textContent = message;

            messageModalContent.classList.remove('border-blue-300', 'border-red-400');
            messageModalContent.classList.add(isSuccess ? 'border-blue-300' : 'border-red-400');

            modal.classList.remove('hidden');
            modal.classList.add('flex');
            
            const currentState = gameState; // Guardar estado actual
             if (currentState === 'PLAYING') {
                setGameState('CINEMATIC');
            }


            if (duration !== null) {
                closeButton.classList.add('hidden');
                setTimeout(() => {
                    modal.classList.add('hidden');
                    modal.classList.remove('flex');
                    
                    // Solo volver a PLAYING si estábamos en CINEMATIC y el juego sigue activo
                    if (gameState === 'CINEMATIC' && currentState !== 'GAME_OVER' && currentState !== 'GAME_WON' && currentView === 'game') {
                         console.log("Auto-closing modal, returning to PLAYING state."); // Log de depuración
                         setGameState('PLAYING');
                    } else {
                         console.log(`Auto-closing modal, NOT returning to PLAYING. Current state: ${gameState}, Initial state: ${currentState}, Current View: ${currentView}`); // Log de depuración
                    }
                }, duration);
            } else {
                closeButton.classList.remove('hidden');
            }
        }


        function showConfirmationModal(message, onConfirm) {
            document.getElementById('confirmationMessage').textContent = message;
            document.getElementById('confirmationModal').classList.add('flex');
            document.getElementById('confirmationModal').classList.remove('hidden');
            
            if (gameState === 'PLAYING') {
                setGameState('CINEMATIC');
            }
            confirmCallback = onConfirm;
        }

        function hideConfirmationModal() {
            document.getElementById('confirmationModal').classList.remove('flex');
            document.getElementById('confirmationModal').classList.add('hidden');
            
            if (gameState === 'CINEMATIC' && currentView === 'game') { // Solo volver si estamos en la pantalla de juego
                 setGameState('PLAYING');
            }
            confirmCallback = null;
        }


        function hideAllModals() {
            const modalIds = [
                'nameInputModal', 'messageModal', 'confirmationModal', 'wordsModal',
                'thiefMiniChallengeModal', 'bossModal', 
                'thiefWhisperModal', 'randomThiefAttackModal', 'thiefDealModal',
                'guardianModal', 'guardianGiftModal' // No ocultar gameOverScreen ni winScreen aquí
            ];
            modalIds.forEach(id => {
                const modal = document.getElementById(id);
                if (modal) {
                    modal.classList.add('hidden');
                    modal.classList.remove('flex');
                    modal.classList.remove('opacity-100', 'opacity-0');
                    if (id === 'bossModal') {
                            const content = document.getElementById('bossModalContent');
                            if(content) content.classList.add('opacity-0', 'scale-95');
                    }
                }
            });
             // Ocultar pantallas finales explícitamente si no estamos en ellas
             if (gameState !== 'GAME_OVER') {
                 const goScreen = document.getElementById('gameOverScreen');
                 if (goScreen) goScreen.classList.add('hidden');
             }
             if (gameState !== 'GAME_WON') {
                 const winScreen = document.getElementById('winScreen');
                 if (winScreen) winScreen.classList.add('hidden');
             }
        }
        
        // Revisado: changeView asegura mostrar la pantalla correcta
        function changeView(view) {
            currentView = view;
            const screenIds = ['gameScreen', 'startupScreen', 'gameOverScreen', 'winScreen', 'gameControls'];
             console.log(`Changing view to: ${view}`); // Log de depuración
            
            // Ocultar todas las pantallas principales primero
            screenIds.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                     element.classList.add('hidden');
                     element.classList.remove('flex'); // Asegurar que flex se quite si no es la pantalla activa
                }
            });

            // Mostrar la pantalla correcta
            const targetScreenId = `${view}Screen`;
            const targetScreen = document.getElementById(targetScreenId);
            if (targetScreen) {
                targetScreen.classList.remove('hidden');
                 // Añadir 'flex' específicamente a las pantallas que lo necesitan
                 if (view === 'gameOver' || view === 'win' || view === 'startup') {
                    targetScreen.classList.add('flex');
                 }
                 console.log(`Showing screen: ${targetScreenId}`); // Log de depuración
            } else {
                 console.error(`Screen element not found: ${targetScreenId}`); // Log de error
            }

            hideAllModals(); // Ocultar todos los modales al cambiar de vista principal
            
            // Lógica específica para gameControls
            const controls = document.getElementById('gameControls');
            if (controls) {
                if (view === 'game') {
                    controls.classList.remove('hidden');
                    controls.classList.add('flex');
                } else {
                    controls.classList.add('hidden');
                    controls.classList.remove('flex');
                }
            }
            
            // Actualizar el estado del juego DESPUÉS de gestionar la UI
            if (view === 'game') {
                setGameState('PLAYING');
            } else if (view === 'startup') {
                setGameState('STARTUP');
            } else if (view === 'gameOver') {
                setGameState('GAME_OVER');
            } else if (view === 'win') {
                setGameState('GAME_WON');
            }
        }
        
        async function startNewGame() {
            // Ya no muestra modal aquí, se reinicia al confirmar nombre
            initializeGameState(); 
            gameStarted = true;
            changeView('game'); 
            await startGameCommon(false); 
            // Ya no muestra modal aquí
        }
        
        function startWordDisplayTimer(duration) {
             console.log(`Starting word timer for ${duration}ms`); // Log de depuración
            clearTimeout(wordDisplayTimeout);
            wordDisplayTimeout = setTimeout(() => {
                if (gameState === 'PLAYING') {
                     console.log("Word timer expired, generating new word."); // Log de depuración
                     generateNewWord(true);
                } else {
                     console.log("Word timer expired, but game state is not PLAYING."); // Log de depuración
                }
            }, duration);
        }

        function triggerLimboGramatical() {
            setGameState('CINEMATIC');

            const modal = document.getElementById('guardianModal');
            const dialogueEl = document.getElementById('guardianDialogue');
            const buttons = document.getElementById('guardianButtons');

            document.getElementById('guardianIcon').innerHTML = ICON_LIBRARY.christopherIcon;
            dialogueEl.textContent = '';
            buttons.classList.add('hidden');

            modal.classList.remove('hidden');
            modal.classList.add('flex');
            setTimeout(() => modal.classList.remove('opacity-0'), 20);

            typeEffect(dialogueEl, "Soy el Guardián del Limbo. Tu entereza ha abierto un camino hasta mí.", () => {
                setTimeout(() => {
                    typeEffect(dialogueEl, "Como recompensa, te ofrezco restaurar tus fuerzas y bendecirte con protección temporal. ¿Aceptas mi regalo?", null, false); 
                }, 500);
            });
        }


        async function generateNewWord(forceNew = false) {
            if (gameState !== 'PLAYING') {
                 console.log("generateNewWord called, but game state is not PLAYING."); // Log de depuración
                 return;
            }
             console.log(`Generating new word. Force new: ${forceNew}`); // Log de depuración
            
            if (forceNew) clearTimeout(wordDisplayTimeout);
            
            if (isWhispering && Math.random() < 0.15) { 
                 console.log("Generating corrupted word."); // Log de depuración
                const randomCorrupted = CORRUPTED_WORDS[Math.floor(Math.random() * CORRUPTED_WORDS.length)];
                const category = randomCorrupted.category;
                const inflationMultiplier = 1 + (passiveIncome / INFLATION_FACTOR); 
                const dynamicValue = Math.floor((HUGE_WORD_DATABASE[category].value + (randomCorrupted.wrong.length * PRICE_PER_LETTER)) * inflationMultiplier);
                currentWord = { word: randomCorrupted.wrong, category: category, value: dynamicValue, isCorrupted: true, rightVersion: randomCorrupted.right, startTime: Date.now() };
                updateUI();
                startWordDisplayTimer(3000);
                return;
            }
            
            const isLimboActive = Date.now() < limboGramaticalEndTime;
            let christopherChance = 0.03; 

            if (Math.random() < christopherChance) {
                 console.log("Generating CHRISTOPHER bonus word."); // Log de depuración
                currentWord = { word: "CHRISTOPHER", category: "Bonus", value: 0, isBonus: true, startTime: Date.now() };
                updateUI();
                startWordDisplayTimer(1000); 
                return;
            }
            
            const nonFinalCategories = Object.keys(WORD_DATABASE).filter(c => c !== "Sobreesdrújulas");
            const incompleteCategories = nonFinalCategories.filter(cat => playerWords[cat] && playerWords[cat].count < WORD_DATABASE[cat].limit);
            let categoryPool = (incompleteCategories.length > 0) ? incompleteCategories : nonFinalCategories;
            const allCategoriesCompleted = nonFinalCategories.every(cat => playerWords[cat] && playerWords[cat].count >= WORD_DATABASE[cat].limit);
            let randomCategory = allCategoriesCompleted ? "Sobreesdrújulas" : categoryPool[Math.floor(Math.random() * categoryPool.length)];
            
             // Asegurarse de que playerWords[randomCategory] exista
             if (!playerWords[randomCategory]) playerWords[randomCategory] = { count: 0, list: [] };
             
            let ownedWords = playerWords[randomCategory]?.list || [];
             let availableWords = (WORD_DATABASE[randomCategory]?.words || []).filter(word => !ownedWords.includes(word));
            
            if (availableWords.length === 0 && randomCategory !== "Sobreesdrújulas" && !allCategoriesCompleted) { 
                 console.log(`Category ${randomCategory} complete, retrying generation.`); // Log de depuración
                setTimeout(() => generateNewWord(true), 50); 
                return;
            }
            // Revisado: Permitir reutilizar Sobreesdrújulas si es la única opción o todas están completas
            if (availableWords.length === 0 && (randomCategory === "Sobreesdrújulas" || allCategoriesCompleted)) { 
                 console.log(`Reusing words from category ${randomCategory}.`); // Log de depuración
                 availableWords = (WORD_DATABASE[randomCategory]?.words || []);
                 // Si aun así no hay palabras (base de datos vacía), parar
                 if (availableWords.length === 0) {
                     console.error(`No words available in category ${randomCategory}, even after allowing reuse.`);
                     currentWord = { word: "ERROR", category: "Error", value: 0, startTime: Date.now() };
                     updateUI();
                     return;
                 }
            }
            
            let randomWord = availableWords[Math.floor(Math.random() * availableWords.length)];
            let isSuperValue = (WORD_DATABASE[randomCategory].superValueWords || []).includes(randomWord);
            
            // Forzar Super Valor si Limbo está activo
            if (isLimboActive && !isSuperValue && randomCategory !== "Sobreesdrújulas" && !currentWord.isBonus && !currentWord.isCorrupted) {
                 console.log("Forcing Super Value due to Limbo."); // Log de depuración
                isSuperValue = true;
            }
            
            let dynamicValue = WORD_DATABASE[randomCategory].value;
            if (randomCategory !== "Sobreesdrújulas") {
                const inflationMultiplier = 1 + (passiveIncome / INFLATION_FACTOR); 
                dynamicValue = Math.floor((WORD_DATABASE[randomCategory].value + (randomWord.length * PRICE_PER_LETTER)) * inflationMultiplier);
                
                if (isSuperValue) {
                    dynamicValue *= SUPER_VALUE_MULTIPLIER;
                }
            }
            
             console.log(`Generated word: ${randomWord} (Category: ${randomCategory}, Value: ${dynamicValue}, SuperValue: ${isSuperValue})`); // Log de depuración
            currentWord = { word: randomWord, category: randomCategory, value: dynamicValue, isSuperValue, startTime: Date.now() };
            updateUI();
            startWordDisplayTimer(3000); 
        }
        
        function formatNumber(num) {
            let parts = num.toFixed(1).toString().split('.');
            parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ',');
            return parts.join('.');
        }


        function updateUI() {
            document.getElementById('playerMoney').textContent = Math.floor(playerMoney).toLocaleString('es-ES').replace(/\./g, ',');
            recalculatePassiveIncome();
            let finalPassiveIncome = passiveIncome;
            if (Date.now() < christopherBoostEndTime) finalPassiveIncome *= 2;
            if (Date.now() < limboGramaticalEndTime) finalPassiveIncome *= 1.21;
            document.getElementById('passiveIncome').textContent = formatNumber(finalPassiveIncome);

            if (currentWord.word) {
                const currentWordEl = document.getElementById('currentWord');
                const wordCategoryEl = document.getElementById('wordCategory');
                const wordValueEl = document.getElementById('wordValue');
                
                if(currentWordEl && wordCategoryEl && wordValueEl) {
                    let wordClass = "";
                    if (currentWord.isBonus) wordClass = "rainbow-text font-black";
                    else if (currentWord.isSuperValue) wordClass = "super-value-text font-black";
                    else if (currentWord.isCorrupted) wordClass = "text-red-700 font-black";
                    else wordClass = `${categoryColors[currentWord.category] || "text-gray-800"} font-black`;
                    
                    currentWordEl.innerHTML = `<span class="${wordClass}">${currentWord.word}</span>`;
                    wordCategoryEl.textContent = currentWord.category;
                    
                    const buyButton = document.getElementById('buyButton');
                    let canAfford = playerMoney >= currentWord.value;
                    let isOwned = false;
                    let isCategoryComplete = false;

                    // Asegurarse de que playerWords[currentWord.category] exista
                    if (currentWord.category && !playerWords[currentWord.category]) {
                         playerWords[currentWord.category] = { count: 0, list: [] };
                    }

                    if (!currentWord.isBonus && !currentWord.isCorrupted && currentWord.category && playerWords[currentWord.category]) {
                        const categoryData = playerWords[currentWord.category];
                        const limit = WORD_DATABASE[currentWord.category]?.limit;
                        isCategoryComplete = categoryData && typeof limit === 'number' && categoryData.count >= limit;
                        isOwned = (categoryData.list || []).includes(currentWord.word);
                    }
                    
                     if (currentWord.category === "Sobreesdrújulas") {
                        currentWord.value = HUGE_WORD_DATABASE["Sobreesdrújulas"].value; 
                        canAfford = playerMoney >= currentWord.value;
                    }
                    
                    buyButton.disabled = (!canAfford && !currentWord.isBonus) || isOwned || isCategoryComplete;
                    buyButton.classList.toggle('opacity-50', buyButton.disabled);
                    buyButton.classList.toggle('cursor-not-allowed', buyButton.disabled);

                    if (isCategoryComplete && currentWord.category !== "Sobreesdrújulas") {
                        wordValueEl.textContent = 'Categoría Completa';
                    } else {
                        let valueHTML = `${Math.floor(currentWord.value).toLocaleString('es-ES').replace(/\./g, ',')}`;
                        wordValueEl.innerHTML = valueHTML;
                    }
                } else {
                     console.error("Error updating current word UI: Elements not found."); // Log de error
                }
            } else {
                 console.log("UpdateUI called but currentWord is empty."); // Log de depuración
            }


            const remainingLives = Math.max(0, 3 - consecutiveFailures);
            const lifeCounter = document.getElementById('lifeCounter');
            lifeCounter.textContent = `${remainingLives}/3`;
            const lifeCounterContainer = document.getElementById('lifeCounterContainer');
            lifeCounterContainer.classList.remove('border-green-300', 'border-yellow-400', 'border-red-500');
            if (remainingLives === 3) lifeCounterContainer.classList.add('border-green-300');
            else if (remainingLives === 2) lifeCounterContainer.classList.add('border-yellow-400');
            else lifeCounterContainer.classList.add('border-red-500');
            
            const now = Date.now();
            const limboIsActive = now < limboGramaticalEndTime;
            
            const inventoryContainer = document.getElementById('inventoryContainer');
             inventoryContainer.innerHTML = ''; // Limpiar antes de volver a llenar
            
            // Asegurarse de que WORD_DATABASE esté inicializado
             if (!WORD_DATABASE || Object.keys(WORD_DATABASE).length === 0) {
                console.error("WORD_DATABASE is empty in updateUI. Regenerating...");
                generatePlaythroughWordDatabase(); // Intentar regenerar si está vacío
                // Asegurarse de que playerWords esté alineado
                Object.keys(WORD_DATABASE).forEach(category => {
                     if (!playerWords[category]) {
                         playerWords[category] = { count: 0, list: [] };
                     }
                });
             }

            Object.keys(WORD_DATABASE).forEach(category => {
                const data = playerWords[category] || { count: 0, list: [] };
                // Añadir comprobación por si WORD_DATABASE[category] no existe (aunque no debería pasar)
                const limit = WORD_DATABASE[category]?.limit; 
                // Si limit no es un número, asumir 0 para evitar errores
                const isCompleted = typeof limit === 'number' ? data.count >= limit : true;

                const categoryDiv = document.createElement('div');
                const bgColor = categoryBackgrounds[category] || 'bg-gray-200'; // Default color
                const textColor = categoryColors[category] || 'text-gray-800'; // Default color
                
                categoryDiv.className = `relative flex-1 flex-shrink-0 text-center flex flex-col items-center justify-between p-2 rounded-lg shadow-md ${isCompleted ? "bg-gray-300 text-gray-500" : bgColor}`;
                
                const isChrisActive = Date.now() < christopherBoostEndTime;
                const isSuperValueActiveForThisCategory = superValueBoosts[category] && Date.now() < superValueBoosts[category];
                let boostIconsHTML = '<div class="absolute top-0 right-1 flex flex-col items-end">';
                if (isChrisActive && category !== "Sobreesdrújulas") boostIconsHTML += `<span class="rainbow-text font-bold text-xs">x2</span>`;
                if (isSuperValueActiveForThisCategory) boostIconsHTML += `<span class="super-value-text font-bold text-xs">x2</span>`;
                boostIconsHTML += '</div>';

                // Mostrar 'N/A' si el límite no está definido
                const limitText = typeof limit === 'number' ? limit : 'N/A';

                categoryDiv.innerHTML = `
                    ${boostIconsHTML}
                    <p class="font-bold ${textColor}">${category}</p>
                    <p class="text-2xl font-extrabold ${textColor}">${data.count}/${limitText}</p>
                `;
                inventoryContainer.appendChild(categoryDiv);
            });
        }


        function checkLimboActivation() {
            const baseChance = 0.05; 
            const criticalChance = 1.0; 
            
            let currentChance = (consecutiveFailures === 2) ? criticalChance : baseChance;
            
            if (!limboTriggeredThisLevel && Math.random() < currentChance) {
                limboTriggeredThisLevel = true; 
                triggerLimboGramatical(); 
            }
        }

        // Revisado: Lógica de victoria
        function buyWord() {
             console.log("Buy button clicked for word:", currentWord?.word); // Log de depuración
            if (playerMoney < currentWord.value && !currentWord.isBonus) {
                 console.log("Cannot afford word."); // Log de depuración
                 return;
             }
            
            if (currentWord.isCorrupted) {
                 console.log("Buying corrupted word."); // Log de depuración
                playerMoney -= currentWord.value;
                corruptedWordsBought++;
                showWhisperModal(BOSS_TAUNT);
                updateUI();
                generateNewWord(true);
                return;
            }
            let wordBought = false;
            if (currentWord.isBonus) {
                 console.log("Activating CHRISTOPHER bonus."); // Log de depuración
                const now = Date.now();
                const baseDuration = 60000;
                const remainingTime = (christopherBoostEndTime > now) ? (christopherBoostEndTime - now) : 0;
                christopherBoostEndTime = now + remainingTime + baseDuration; 
                wordBought = true;
            } else {
                 console.log("Attempting to buy regular word:", currentWord.word, "Category:", currentWord.category); // Log de depuración
                 // Asegurar que playerWords[currentWord.category] exista
                 if (!playerWords[currentWord.category]) {
                      playerWords[currentWord.category] = { count: 0, list: [] };
                      console.log("Initialized playerWords for category:", currentWord.category); // Log de depuración
                 }
                 
                const categoryData = playerWords[currentWord.category];
                 const limit = WORD_DATABASE[currentWord.category]?.limit;

                 // Añadir logs para depuración
                 console.log(`Category Data: count=${categoryData.count}, limit=${limit}`);
                 console.log(`Word already in list? ${categoryData.list.includes(currentWord.word)}`);

                 // Revisado: Condición de compra
                if (typeof limit === 'number' && categoryData.count < limit && !categoryData.list.includes(currentWord.word)) {
                     console.log("Buying new word."); // Log de depuración
                    playerMoney -= currentWord.value;
                    categoryData.count++;
                    categoryData.list.push(currentWord.word);
                    wordBought = true;
                    if (currentWord.isSuperValue) {
                         console.log("Activating Super Value bonus."); // Log de depuración
                        const now = Date.now();
                        const category = currentWord.category;
                        const baseDuration = 10000;
                        const remainingTime = (superValueBoosts[category] > now) ? (superValueBoosts[category] - now) : 0;
                        superValueBoosts[category] = now + remainingTime + baseDuration; 
                    }
                 } else if (currentWord.category === "Sobreesdrújulas") {
                      // Permitir comprar Sobreesdrújulas múltiples veces si ya se tiene una, pero solo contar la primera vez para la victoria
                      console.log("Buying Sobreesdrújula."); // Log de depuración
                      playerMoney -= currentWord.value;
                      wordBought = true; // Marcar como comprada para actualizar UI y timer
                      
                      // Lógica de victoria específica para la primera vez
                       if (!playerWords["Sobreesdrújulas"] || !playerWords["Sobreesdrújulas"].list.includes(currentWord.word)) {
                            console.log("First time buying this Sobreesdrújula - WIN CONDITION CHECK"); // Log de depuración
                            if (!playerWords["Sobreesdrújulas"]) playerWords["Sobreesdrújulas"] = { count: 0, list: [] };
                            playerWords["Sobreesdrújulas"].list.push(currentWord.word); 
                            playerWords["Sobreesdrújulas"].count = 1; // El contador solo llega a 1

                            const { date, time } = getFormattedDateTime();
                            const winReport = `¡VICTORIA, ${playerName}! Has ganado el ${date} a las ${time}.`;
                            console.log("Win condition met, preparing win screen..."); // Log de depuración
                            document.getElementById('winMessage').textContent = winReport;
                            
                            const restartBtn = document.getElementById('reiniciarButton');
                            if(restartBtn) restartBtn.disabled = false;
                            
                            console.log("Calling changeView('win')..."); // Log de depuración
                            changeView('win');
                            return; // Importante salir para no procesar más lógica
                       }
                 } else {
                     console.log("Word is already owned or category is full."); // Log de depuración
                 }
            }

            // Continuar con la lógica normal si no se ganó y se compró algo
            if (wordBought) {
                if (!hasBoughtFirstWord) hasBoughtFirstWord = true;
                
                if (!currentWord.isBonus) {
                    playerStats.wordsBought++; 
                     console.log("Total words bought:", playerStats.wordsBought); // Log de depuración
                }

                document.getElementById('buyButton').disabled = true;
                 updateUI(); // Actualización visual inmediata
                clearTimeout(wordDisplayTimeout);
                
                // Aplazar lógica pesada para evitar "tirones"
                setTimeout(() => {
                    // Solo ejecutar si el juego sigue activo (no en GAME_WON)
                    if (gameState === 'PLAYING') { 
                        if (!currentWord.isBonus) {
                            checkBossEncounter(); 
                        }
                        
                        checkLimboActivation(); 
                        
                        // Calcular el tiempo restante para el enfriamiento
                        const elapsedTime = Date.now() - currentWord.startTime;
                        const duration = currentWord.isBonus ? 1000 : 3000;
                        const newRemainingTime = Math.max(100, (duration - elapsedTime) - 1000); // 100ms de enfriamiento mínimo
                        startWordDisplayTimer(newRemainingTime);
                    }
                }, 0); 
            }
        }
        
        function startThiefMiniChallenge(forcedType = null) {
            const allCategoriesCompleted = Object.keys(WORD_DATABASE).filter(c => c !== "Sobreesdrújulas").every(cat => playerWords[cat] && playerWords[cat].count >= WORD_DATABASE[cat].limit);
            
            if (gameState !== 'PLAYING' || allCategoriesCompleted) return;
            
            setGameState('CHALLENGE_MINI');
            playThiefMusic(); 

            const challengeTypes = ['accent', 'trueFalse', 'tonicSyllable'];
            const type = forcedType || challengeTypes[Math.floor(Math.random() * challengeTypes.length)];
            currentChallengeData = { type };

            const modal = document.getElementById('thiefMiniChallengeModal');
            const descriptionEl = document.getElementById('challengeDescription');
            const questionEl = document.getElementById('challengeQuestion');
            const inputContainer = document.getElementById('challengeInputContainer');
            const buttonsContainer = document.getElementById('challengeButtonsContainer');
            const inputEl = document.getElementById('challengeInput');
            const timerEl = document.getElementById('challengeTimer');

            document.getElementById('thiefMiniChallengeIcon').innerHTML = ICON_LIBRARY.bossIcon;
            inputEl.value = '';

            let timeLeft;

            switch (type) {
                case 'accent':
                    timeLeft = 20;
                    descriptionEl.textContent = 'Escribe la palabra con la tilde correcta:';
                    const accentChallenge = MINI_CHALLENGE_WORDS.accent[Math.floor(Math.random() * MINI_CHALLENGE_WORDS.accent.length)];
                    currentChallengeData.answer = accentChallenge.right;
                    questionEl.textContent = accentChallenge.wrong;
                    inputContainer.classList.remove('hidden');
                    buttonsContainer.classList.add('hidden');
                    inputEl.focus();
                    break;
                case 'trueFalse':
                    timeLeft = 20;
                    descriptionEl.textContent = '¿La clasificación es correcta?';
                    const tfChallenge = MINI_CHALLENGE_WORDS.trueFalse[Math.floor(Math.random() * MINI_CHALLENGE_WORDS.trueFalse.length)];
                    currentChallengeData.answer = tfChallenge.isCorrect;
                    questionEl.textContent = `"${tfChallenge.word}" - ${tfChallenge.category}`;
                    inputContainer.classList.add('hidden');
                    buttonsContainer.classList.remove('hidden');
                    buttonsContainer.classList.add('flex');
                    break;
                case 'tonicSyllable': 
                    timeLeft = 25;
                    descriptionEl.textContent = 'Escribe la sílaba tónica (sin tilde):';
                    const tonicChallenge = TONIC_SYLLABLE_WORDS[Math.floor(Math.random() * TONIC_SYLLABLE_WORDS.length)];
                    currentChallengeData.answer = tonicChallenge.syllable.toLowerCase(); 
                    questionEl.textContent = tonicChallenge.word;
                    inputContainer.classList.remove('hidden');
                    buttonsContainer.classList.add('hidden');
                    inputEl.focus();
                    break;
            }
            
            modal.classList.remove('hidden');
            modal.classList.add('flex');
            
            timerEl.textContent = timeLeft;
            challengeTimerInterval = setInterval(() => {
                timeLeft--;
                timerEl.textContent = timeLeft;
                if (timeLeft <= 0) endThiefMiniChallenge(null);
            }, 1000);
        }

        function endThiefMiniChallenge(playerAnswer) {
            clearInterval(challengeTimerInterval);
            
            playMainMusic();
            
            const modal = document.getElementById('thiefMiniChallengeModal');
            modal.classList.add('hidden');
            modal.classList.remove('flex');
            
            let isCorrect = false;
            let failureReason = "Respuesta incorrecta.";
            
            switch (currentChallengeData.type) {
                case 'accent':
                case 'tonicSyllable': 
                    if (playerAnswer && playerAnswer.trim().toLowerCase() === currentChallengeData.answer) {
                        isCorrect = true;
                    }
                    if(!playerAnswer) {
                        failureReason = "No se introdujo respuesta.";
                    } else if (currentChallengeData.type === 'accent') {
                        failureReason = `Incorrecto. La respuesta era "${currentChallengeData.answer}".`;
                    } else { 
                         failureReason = `Incorrecto. La sílaba tónica era "${currentChallengeData.answer}".`;
                    }
                    break;
                case 'trueFalse':
                    if (playerAnswer === currentChallengeData.answer) {
                        isCorrect = true;
                    }
                    failureReason = `Incorrecto. La clasificación era ${currentChallengeData.answer ? 'Verdadera' : 'Falsa'}.`;
                    break;
            }

            if(playerAnswer === null) failureReason = "Se acabó el tiempo.";

            if (isCorrect) {
                playerStats.challengesWon++; 
                const reward = CHALLENGE_REWARDS.base; 
                playerMoney += reward;
                showModal(`¡Correcto! Ganas ${reward.toLocaleString('es-ES', { useGrouping: true }).replace(/\./g, ',')}.`);
            } else {
                handleChallengeFailure(failureReason);
            }
             // Asegurar que volvamos al estado de juego si no perdimos
             if (gameState !== 'GAME_OVER') {
                  setGameState('PLAYING');
             }
        }
        
        function handleChallengeFailure(reason) {
            consecutiveFailures++;
            
            if (consecutiveFailures === 1 && guardianBlessingAvailable) {
                guardianBlessingAvailable = false; 
                if (guardianBlessingTimeout) clearTimeout(guardianBlessingTimeout); 
                guardianBlessingTimeout = setTimeout(() => {
                    if (gameState !== 'GAME_OVER' && consecutiveFailures > 0) { 
                        consecutiveFailures--;
                        showGuardianGiftModal("El Guardián sintió tu tropiezo...", "¡Te devuelve 1 vida!");
                        updateUI(); 
                    }
                    guardianBlessingTimeout = null; 
                }, 21000); 
            }

            checkForThiefDeal(() => {
                showWhisperModal(BOSS_TAUNT, () => {
                    showFailureMessage(reason);
                });
            });
        }
        
        function showFailureMessage(reason) {
            if (consecutiveFailures >= 3) {
                 if (guardianBlessingTimeout) { 
                    clearTimeout(guardianBlessingTimeout);
                    guardianBlessingTimeout = null;
                 }
                document.getElementById('gameOverMessage').textContent = `Fallaste 3 veces. Razón final: ${reason}`;
                changeView('gameOver');
            } else {
                resetProgressButKeepLives();
                 // showModal se encargará de cambiar a CINEMATIC y volver a PLAYING
                showModal(`¡Fallo! ${reason}. Has perdido tus palabras. Te quedan ${3 - consecutiveFailures} intentos.`, 4000, false); 
            }
        }
       
        function showBossModal() {
            const modal = document.getElementById('bossModal');
            const modalContent = document.getElementById('bossModalContent');
            modal.classList.remove('hidden');
            modal.classList.add('flex'); 
            setTimeout(() => {
                modal.classList.remove('opacity-0');
                modalContent.classList.remove('opacity-0', 'scale-95');
            }, 20);
        }

        function hideBossModal(callback) {
            const modal = document.getElementById('bossModal');
            const modalContent = document.getElementById('bossModalContent');
            modal.classList.add('opacity-0');
            modalContent.classList.add('opacity-0', 'scale-95');
            setTimeout(() => {
                modal.classList.add('hidden');
                modal.classList.remove('flex');
                if (callback) callback();
            }, 300);
        }

        function checkBossEncounter() {
            if (gameState !== 'PLAYING') return;
            
            const wordsPurchased = playerStats.wordsBought; 
            const nextBossLevel = bossesDefeated.length + 1;
            const milestone = BOSS_MILESTONES[nextBossLevel];
            
            if (!milestone || bossesDefeated.includes(nextBossLevel)) return;
            
            const whisperThreshold = milestone - 5; 
            
            if (wordsPurchased >= milestone) {
                 console.log(`Milestone reached (${milestone}), starting boss challenge level ${nextBossLevel}.`); // Log de depuración
                startBossChallenge(nextBossLevel);
            } else if (wordsPurchased >= whisperThreshold && !isWhispering) { 
                 console.log("Whisper threshold reached."); // Log de depuración
                isWhispering = true; 
            }
        }

        function startBossChallenge(level) {
            isWhispering = false;
            activeWhisper = "";
            
            setGameState('CHALLENGE_BOSS');
            playThiefMusic();
            
            currentBossLevel = level;
            const sentencesForLevel = BOSS_SENTENCES[level] || BOSS_SENTENCES[Object.keys(BOSS_SENTENCES).pop()]; 
            currentBossSentence = sentencesForLevel[Math.floor(Math.random() * sentencesForLevel.length)];
            
            const dialogueEl = document.getElementById('bossDialogue');
            const challengeContent = document.getElementById('bossChallengeContent');
            const sentenceEl = document.getElementById('bossChallengeSentence');
            const inputEl = document.getElementById('bossChallengeInput');
            const timerEl = document.getElementById('bossTimer');
            document.getElementById('bossIconContainer').innerHTML = ICON_LIBRARY.bossIcon;
            challengeContent.classList.add('hidden');
            inputEl.value = '';
            dialogueEl.textContent = '';
            showBossModal();
            const dialogueText = BOSS_INITIAL_DIALOGUES[Math.floor(Math.random() * BOSS_INITIAL_DIALOGUES.length)];
            typeEffect(dialogueEl, dialogueText, () => {
                challengeContent.classList.remove('hidden');
                sentenceEl.textContent = currentBossSentence.wrong;
                inputEl.focus();
                const totalTime = 60;
                const timeDebuffPerWord = 0.03; 
                const timeDebuff = totalTime * timeDebuffPerWord * corruptedWordsBought; 
                let timeLeft = Math.max(15, Math.floor(totalTime - timeDebuff));
                timerEl.textContent = timeLeft;
                bossTimerInterval = setInterval(() => {
                    timeLeft--;
                    timerEl.textContent = timeLeft;
                    if (timeLeft <= 0) endBossChallenge(false);
                }, 1000);
            });
            inputEl.onkeyup = (event) => {
                if (event.key === 'Enter') endBossChallenge(inputEl.value.trim() === currentBossSentence.right);
            };
        }

        function typeEffect(element, text, onCompleteCallback, autoCloseDelay = null) {
            let i = 0;
            element.textContent = '';
            const modalContent = element.closest('.bg-gray-800, .bg-white');
            const dealButtons = modalContent?.querySelector('#thiefDealButtons');
            const giftButtons = modalContent?.querySelector('#guardianButtons');
            
            if (dealButtons) dealButtons.classList.add('hidden');
            if (giftButtons) giftButtons.classList.add('hidden');

            function type() {
                if (i < text.length) {
                    element.textContent += text.charAt(i);
                    i++;
                    setTimeout(type, 50); 
                } else {
                    // Mostrar botones solo si no hay autocierre Y no hay callback que vaya a mostrar otra cosa
                    if ((autoCloseDelay === null || autoCloseDelay === false) && !onCompleteCallback) {
                        if (dealButtons) {
                            dealButtons.classList.remove('hidden');
                            dealButtons.classList.add('flex');
                        }
                        if (giftButtons) {
                            giftButtons.classList.remove('hidden');
                            giftButtons.classList.add('flex');
                        }
                    }
                    // Ejecutar callback si existe
                    if (onCompleteCallback) setTimeout(onCompleteCallback, 500); 

                    // Lógica de autocierre
                    if(typeof autoCloseDelay === 'number') {
                        setTimeout(() => {
                            const modal = element.closest('.boss-modal-bg, .christopher-modal-bg');
                            if (modal) {
                                modal.classList.add('opacity-0');
                                setTimeout(() => {
                                    modal.classList.add('hidden');
                                    modal.classList.remove('flex');
                                    
                                     // Revisado: Volver a PLAYING solo si estábamos en CINEMATIC y en la vista de juego
                                    if (gameState === 'CINEMATIC' && currentView === 'game') {
                                         console.log("Auto-closing typeEffect modal, returning to PLAYING."); // Log de depuración
                                         setGameState('PLAYING');
                                    } else {
                                         console.log(`Auto-closing typeEffect modal, NOT returning to PLAYING. State: ${gameState}, View: ${currentView}`); // Log de depuración
                                    }
                                }, 300);
                            }
                        }, autoCloseDelay);
                    }
                }
            }
            type();
        }

        async function endBossChallenge(isCorrect) {
            clearInterval(bossTimerInterval);
            
            setGameState('CINEMATIC'); // Poner en cinemática para mostrar resultado
            
            document.getElementById('bossChallengeContent').classList.add('hidden');
            const dialogueEl = document.getElementById('bossDialogue');
            dialogueEl.textContent = '';
            
            if (isCorrect) {
                 console.log(`Boss level ${currentBossLevel} defeated.`); // Log de depuración
                bossesDefeated.push(currentBossLevel);
                playerStats.bossesDefeatedCount = bossesDefeated.length;
                const rewardPercentage = { 1: 0.10, 2: 0.15, 3: 0.20, 4: 0.25, 5: 0.30, 6: 0.35, 7: 0.40, 8: 0.50 }[currentBossLevel] || 0.05; 
                const moneyReward = Math.floor(playerMoney * rewardPercentage);
                playerMoney += moneyReward;
                
                const finalDialogue = BOSS_VICTORY_DIALOGUES[Math.floor(Math.random() * BOSS_VICTORY_DIALOGUES.length)];
                const resultMessage = `¡VICTORIA! Ganas un ${Math.floor(rewardPercentage * 100)}% de tu dinero (+${moneyReward.toLocaleString('es-ES', { useGrouping: true }).replace(/\./g, ',')}).`;
                typeEffect(dialogueEl, finalDialogue, () => hideBossModal(() => {
                    playMainMusic(); 
                     // showModal cambiará a CINEMATIC y luego volverá a PLAYING
                    showModal(resultMessage); 
                }));
            } else {
                 console.log(`Boss level ${currentBossLevel} failed.`); // Log de depuración
                consecutiveFailures++;
                
                if (consecutiveFailures === 1 && guardianBlessingAvailable) {
                     guardianBlessingAvailable = false;
                     if (guardianBlessingTimeout) clearTimeout(guardianBlessingTimeout);
                     guardianBlessingTimeout = setTimeout(() => {
                        if (gameState !== 'GAME_OVER' && consecutiveFailures > 0) {
                            consecutiveFailures--;
                            showGuardianGiftModal("El Guardián sintió tu tropiezo...", "¡Te devuelve 1 vida!");
                            updateUI();
                        }
                        guardianBlessingTimeout = null;
                     }, 21000);
                }

                checkForThiefDeal(() => {
                    let moneyLost = playerMoney * ({ 1: 0.10, 2: 0.20, 3: 0.30, 4: 0.40, 5: 0.50, 6: 0.50, 7: 0.50, 8: 0.50 }[currentBossLevel] || 0); 
                    playerMoney = Math.max(0, playerMoney - Math.floor(moneyLost));
                    const finalDialogue = BOSS_DEFEAT_DIALOGUES[Math.floor(Math.random() * BOSS_DEFEAT_DIALOGUES.length)];
                    const resultMessage = `¡DERROTA! El Ladrón te roba ${Math.floor(moneyLost).toLocaleString('es-ES', { useGrouping: true }).replace(/\./g, ',')}. Pierdes 1 vida.`;
                    
                    typeEffect(dialogueEl, finalDialogue, () => hideBossModal(() => {
                        playMainMusic(); 
                        if (consecutiveFailures >= 3) {
                             if (guardianBlessingTimeout) { 
                                clearTimeout(guardianBlessingTimeout);
                                guardianBlessingTimeout = null;
                             }
                            document.getElementById('gameOverMessage').textContent = `Fallaste 3 veces. El Ladrón de Tildes fue tu perdición.`;
                            changeView('gameOver'); 
                        } else {
                             // showModal cambiará a CINEMATIC y luego volverá a PLAYING
                            showModal(resultMessage, 4000, false); 
                        }
                    }));
                }); 
            } 
             // Asegurar actualización de UI después del combate
             updateUI();
        } 

        function triggerRandomEvent() {
            const allCategoriesCompleted = Object.keys(WORD_DATABASE).filter(c => c !== "Sobreesdrújulas").every(cat => playerWords[cat] && playerWords[cat].count >= WORD_DATABASE[cat].limit);
            
            if (!gameStarted || gameState !== 'PLAYING' || !hasBoughtFirstWord || allCategoriesCompleted) return;

            const rand = Math.random();
             console.log(`Random event check. Rand: ${rand.toFixed(2)}`); // Log de depuración

            if (rand < 0.04) { console.log("Triggering mini-challenge: accent"); startThiefMiniChallenge('accent'); }         
            else if (rand < 0.07) { console.log("Triggering mini-challenge: trueFalse"); startThiefMiniChallenge('trueFalse'); }  
            else if (rand < 0.10) { console.log("Triggering mini-challenge: tonicSyllable"); startThiefMiniChallenge('tonicSyllable'); } 
            else if (rand < 0.20) {
                console.log("Triggering random thief attack."); // Log de depuración
                let attackType;
                const attackDialogues = {
                    lifeTheft: "Qué descuidado... Dejas tus vidas tan expuestas. Permíteme aligerar tu carga.",
                    incomeTheft: "Ese tintineo de monedas... es música para mis oídos. Pagarás un pequeño peaje.",
                    wordTheft: "Una colección impresionante. Sería una lástima que... desaparecieran algunas palabras, ¿no?"
                };

                if (!hasHadFirstRandomAttackThisPartida) {
                    attackType = 'lifeTheft';
                    hasHadFirstRandomAttackThisPartida = true;
                } else {
                    const attacks = ['incomeTheft', 'wordTheft'];
                    attackType = attacks[Math.floor(Math.random() * attacks.length)];
                }
                 console.log(`Thief attack type: ${attackType}`); // Log de depuración

                showRandomThiefAttackModal(
                    () => { 
                        switch (attackType) {
                            case 'lifeTheft':
                                return { title: 'Robo de Vidas', effectText: "¡Has perdido 1 vida!", onComplete: () => {
                                    consecutiveFailures++;
                                    if (consecutiveFailures === 1 && guardianBlessingAvailable) {
                                         guardianBlessingAvailable = false;
                                         if (guardianBlessingTimeout) clearTimeout(guardianBlessingTimeout);
                                         guardianBlessingTimeout = setTimeout(() => {
                                            if (gameState !== 'GAME_OVER' && consecutiveFailures > 0) {
                                                consecutiveFailures--;
                                                showGuardianGiftModal("El Guardián sintió tu tropiezo...", "¡Te devuelve 1 vida!");
                                                updateUI();
                                            }
                                            guardianBlessingTimeout = null;
                                         }, 21000);
                                    }
                                    checkForThiefDeal(() => {
                                        updateUI();
                                        if (consecutiveFailures >= 3) {
                                            if (guardianBlessingTimeout) { clearTimeout(guardianBlessingTimeout); guardianBlessingTimeout = null; } 
                                            showFailureMessage("El Ladrón te ha dado el golpe de gracia.");
                                        }
                                    });
                                }};
                            case 'incomeTheft':
                                const moneyStolen = Math.floor(playerMoney * 0.15);
                                return { title: 'Robo de Ingresos', effectText: `¡Te ha robado el 15% de tu dinero! (-${moneyStolen.toLocaleString('es-ES', { useGrouping: true }).replace(/\./g, ',')})`, onComplete: () => {
                                    playerMoney -= moneyStolen;
                                    updateUI();
                                }};
                            case 'wordTheft':
                                const ownableCategories = Object.keys(playerWords).filter(cat => cat !== "Sobreesdrújulas" && playerWords[cat]?.count > 0);
                                if (ownableCategories.length > 0) {
                                    const randomCategory = ownableCategories[Math.floor(Math.random() * ownableCategories.length)];
                                    const wordsInCategory = playerWords[randomCategory].list;
                                    const wordsToStealCount = Math.max(1, Math.floor(wordsInCategory.length * 0.10));
                                    
                                    return { title: 'Robo de Palabras', effectText: `¡Ha robado ${wordsToStealCount} palabra(s) de la categoría ${randomCategory}!`, onComplete: () => {
                                        for(let i = 0; i < wordsToStealCount; i++) {
                                            if(wordsInCategory.length > 0) {
                                                const randomIndex = Math.floor(Math.random() * wordsInCategory.length);
                                                wordsInCategory.splice(randomIndex, 1);
                                            }
                                        }
                                        playerWords[randomCategory].count -= wordsToStealCount;
                                        updateUI();
                                    }};
                                } else { 
                                     const moneyStolenFallback = Math.floor(playerMoney * 0.15);
                                     return { title: 'Robo de Ingresos', effectText: `Iba a robar palabras, pero no tienes. Me conformo con ${moneyStolenFallback.toLocaleString('es-ES', { useGrouping: true }).replace(/\./g, ',')}`, onComplete: () => {
                                        playerMoney -= moneyStolenFallback;
                                        updateUI();
                                    }};
                                }
                        }
                    }
                );
            }
            else if (rand < 0.40) { 
                 console.log("Triggering guardian gift."); // Log de depuración
                 triggerGuardianGift();
            } else {
                 console.log("No random event triggered this cycle."); // Log de depuración
            }
        }
        
        function triggerGuardianGift() {
            const giftRand = Math.random();
            let dialogue, effectText;
            let moneyGained = 0;

            if (giftRand < 0.95) { 
                 console.log("Guardian gift: Wealth."); // Log de depuración
                dialogue = "Veo tu esfuerzo, acepta esta ayuda.";
                const moneyPercent = 0.05 + Math.random() * 0.10; 
                moneyGained = Math.floor(playerMoney * moneyPercent);
                effectText = `¡Don de Riqueza! (+${moneyGained.toLocaleString('es-ES', { useGrouping: true }).replace(/\./g, ',')})`;
                playerMoney += moneyGained;
            } else { 
                 console.log("Guardian gift: Protection (Limbo)."); // Log de depuración
                dialogue = "¡Protégete de la oscuridad!";
                effectText = "¡Don de Protección! (Limbo Gramatical +1 min)";
                limboGramaticalEndTime = Date.now() + 60000; 
            }
            
            showGuardianGiftModal(dialogue, effectText);
            updateUI(); 
        }

        function showGuardianGiftModal(dialogue, effectText) {
            const modal = document.getElementById('guardianGiftModal');
            const dialogueEl = document.getElementById('guardianGiftDialogue');
            const effectDiv = document.getElementById('guardianGiftEffect');
            const effectTextEl = document.getElementById('guardianGiftEffectText');
            
            document.getElementById('guardianGiftIcon').innerHTML = ICON_LIBRARY.christopherIcon;
            
            dialogueEl.textContent = '';
            effectDiv.classList.add('hidden');
            
            setGameState('CINEMATIC');
            
            modal.classList.remove('hidden');
            modal.classList.add('flex'); 
            setTimeout(() => modal.classList.remove('opacity-0'), 20);

            typeEffect(dialogueEl, dialogue, () => {
                effectTextEl.textContent = effectText;
                effectDiv.classList.remove('hidden');
            }, 4000); 
        }

        function showRandomThiefAttackModal(getAttackDetailsCallback) {
            const modal = document.getElementById('randomThiefAttackModal');
            const dialogueEl = document.getElementById('randomThiefDialogue');
            const effectDiv = document.getElementById('randomThiefEffect');
            const effectTextEl = document.getElementById('randomThiefEffectText');
            
            document.getElementById('randomThiefIcon').innerHTML = ICON_LIBRARY.bossIcon;
            
            dialogueEl.textContent = ''; 
            dialogueEl.classList.add('hidden'); 
            effectDiv.classList.add('hidden');
            
            setGameState('CINEMATIC');
            playThiefMusic(); 

            modal.classList.remove('hidden');
            modal.classList.add('flex'); 
            setTimeout(() => modal.classList.remove('opacity-0'), 20);

            const { title, effectText, onComplete } = getAttackDetailsCallback();
            modal.querySelector('h4').textContent = `El Ladrón de Tildes ataca: ${title}`;
            effectTextEl.textContent = effectText;
            effectDiv.classList.remove('hidden');
            onComplete();

            setTimeout(() => {
                modal.classList.add('opacity-0');
                setTimeout(() => {
                    modal.classList.add('hidden');
                    modal.classList.remove('flex');
                    // Revisado: Usar gameState directamente
                    if (gameState === 'CINEMATIC' && currentView === 'game') { 
                         setGameState('PLAYING');
                    }
                }, 300);
            }, 4000); 
        }

        function showWhisperModal(dialogue, onCompleteCallback = null) {
            const modal = document.getElementById('thiefWhisperModal');
            const dialogueEl = document.getElementById('thiefWhisperDialogue');
            
            document.getElementById('thiefWhisperIcon').innerHTML = ICON_LIBRARY.bossIcon;
            
            setGameState('CINEMATIC');
            playThiefMusic(); 

            modal.classList.remove('hidden', 'opacity-0');
            modal.classList.add('flex'); 
            
            typeEffect(dialogueEl, dialogue, onCompleteCallback, 4000); // Autoclose after 4 seconds
        }

        function checkForThiefDeal(callbackOnNoDeal) {
            if ( (3 - consecutiveFailures) === 1 && gameState !== 'GAME_OVER') {
                 console.log("Checking for thief deal."); // Log de depuración
                setGameState('CINEMATIC');
                playThiefMusic(); 

                let bestCategory = null;
                let maxIncome = -1;

                Object.keys(playerWords).forEach(category => {
                    if (playerWords[category] && WORD_DATABASE[category] && category !== "Sobreesdrújulas" && playerWords[category].count > 0) {
                        const count = playerWords[category].count;
                        const baseValue = WORD_DATABASE[category].value;
                        const categoryIncome = count * baseValue;
                        if (categoryIncome > maxIncome) {
                            maxIncome = categoryIncome;
                            bestCategory = category;
                        }
                    }
                });

                if (bestCategory) {
                     console.log(`Offering deal for category: ${bestCategory}`); // Log de depuración
                    const modal = document.getElementById('thiefDealModal');
                    const dialogueEl = document.getElementById('thiefDealDialogue');
                    const buttons = document.getElementById('thiefDealButtons');
                    buttons.classList.add('hidden');
                    document.getElementById('thiefDealIcon').innerHTML = ICON_LIBRARY.bossIcon;
                    
                    modal.classList.remove('hidden', 'opacity-0');
                    modal.classList.add('flex'); 
                    
                    typeEffect(dialogueEl, `Veo que estás al límite... Te ofrezco un trato. Te devuelvo una vida, pero a cambio me quedaré con todas tus palabras de la categoría "${bestCategory}". ¿Aceptas?`, null, false);
                    
                    document.getElementById('acceptDealButton').onclick = () => {
                         console.log("Deal accepted."); // Log de depuración
                        consecutiveFailures--;
                        playerWords[bestCategory] = { count: 0, list: [] };
                        modal.classList.add('hidden', 'opacity-0');
                        modal.classList.remove('flex');
                        playMainMusic(); 
                        showModal("Trato aceptado. Has recuperado una vida, pero tus palabras han desaparecido.");
                         updateUI(); // Actualizar UI para reflejar cambio de vidas y palabras
                    };
                    document.getElementById('rejectDealButton').onclick = () => {
                         console.log("Deal rejected."); // Log de depuración
                        dealRejectedForLimboBoost = true; 
                        modal.classList.add('hidden', 'opacity-0');
                        modal.classList.remove('flex');
                        
                        playMainMusic(); 
                        if (callbackOnNoDeal) callbackOnNoDeal();
                    };
                } else {
                     console.log("No category eligible for deal."); // Log de depuración
                     playMainMusic(); 
                     // Volver a PLAYING si estábamos en cinemática
                     if (gameState === 'CINEMATIC') setGameState('PLAYING');
                     if (callbackOnNoDeal) callbackOnNoDeal();
                }

            } else {
                 console.log("Not eligible for deal (not 1 life left or game over)."); // Log de depuración
                if (callbackOnNoDeal) callbackOnNoDeal();
            }
        }
        
        function mainGameLoop(timestamp) {
            if (gameState !== 'PLAYING') {
                animationFrameId = null; 
                return;
            }
            
            if (!lastUpdateTime) lastUpdateTime = timestamp;
            const deltaTime = timestamp - lastUpdateTime;
            lastUpdateTime = timestamp;
            timeSinceLastIncomeUpdate += deltaTime;
            if (timeSinceLastIncomeUpdate >= 1000) {
                let incomeThisSecond = passiveIncome;
                if (Date.now() < christopherBoostEndTime) incomeThisSecond *= 2;
                if(Date.now() < limboGramaticalEndTime) incomeThisSecond *= 1.21;
                playerMoney += incomeThisSecond;
                timeSinceLastIncomeUpdate = 0;
                
                updateUI();
            }
            updateTimerBarUI();
            animationFrameId = requestAnimationFrame(mainGameLoop);
        }
        
        function updateTimerBarUI() {
            // Asegurarse de que solo corra si estamos jugando
            if (gameState !== 'PLAYING' || !gameStarted || !currentWord.startTime) return; 
            const bar = document.getElementById('wordTimerBar');
            if (!bar) return;
            const now = Date.now();
            const duration = currentWord.isBonus ? 1000 : 3000;
            const elapsedTime = now - currentWord.startTime;
            const timeLeft = Math.max(0, duration - elapsedTime);
            const percentage = (timeLeft / duration) * 100;
            bar.style.width = `${percentage}%`;
            // Cambiar color basado en el tiempo restante
            if (percentage > 66) bar.style.backgroundColor = '#22c55e'; // Verde
            else if (percentage > 33) bar.style.backgroundColor = '#eab308'; // Amarillo
            else bar.style.backgroundColor = '#ef4444'; // Rojo
        }


        const accentuationRules = [
            { title: "Monosílabos", text: "Por regla general, no llevan tilde, salvo en casos de tilde diacrítica.", color: "text-gray-800"},
            { title: "Palabras Agudas", text: "Llevan tilde cuando terminan en 'n', 's' o vocal. La sílaba tónica es la última.", color: "text-green-700" },
            { title: "Palabras Llanas (o Graves)", text: "Llevan tilde cuando NO terminan en 'n', 's' o vocal. La sílaba tónica es la penúltima.", color: "text-yellow-700" },
            { title: "Palabras Esdrújulas", text: "Siempre llevan tilde. La sílaba tónica es la antepenúltima.", color: "text-blue-700" },
            { title: "Palabras Sobreesdrújulas", text: "Siempre llevan tilde. La sílaba tónica es anterior a la antepenúltima.", color: "text-purple-700" }
        ];
        let currentRuleIndex = 0;
        let rulesInterval = null;

        function startRulesRotator() {
            stopRulesRotator(); 
            const rulesContainer = document.getElementById('rulesContainer');
            if (rulesContainer) rulesContainer.classList.remove('hidden');
            const updateRule = () => {
                const rulesDisplay = document.getElementById('rulesDisplay');
                if (!rulesDisplay) return;
                rulesDisplay.style.opacity = 0;
                setTimeout(() => {
                    const rule = accentuationRules[currentRuleIndex];
                    rulesDisplay.innerHTML = `<h3 class="text-lg font-bold ${rule.color}">${rule.title}</h3><p class="text-gray-700">${rule.text}</p>`;
                    rulesDisplay.style.opacity = 1;
                    currentRuleIndex = (currentRuleIndex + 1) % accentuationRules.length;
                }, 200); 
            };
            updateRule(); 
            rulesInterval = setInterval(updateRule, 15000);
        }

        function stopRulesRotator() {
            if (rulesInterval) clearInterval(rulesInterval);
            rulesInterval = null;
            const rulesContainer = document.getElementById('rulesContainer');
            if(rulesContainer) rulesContainer.classList.add('hidden');
        }

        async function initializeAudio() {
             if (audioInitialized) return;
             try {
                console.log("Audio context will start on user interaction.");
                setupMusic();
                Tone.Transport.start();
                audioInitialized = true; 
             } catch (e) {
                 console.error("Error setting up audio:", e);
             }
        }

        function setupMusic() {
            const mainReverb = new Tone.Reverb(1.5).toDestination();
            const chorus = new Tone.Chorus(4, 2.5, 0.7).connect(mainReverb);
            const thiefReverb = new Tone.Reverb(5).toDestination();
            
            mainSynth = new Tone.PolySynth(Tone.FMSynth, {
                harmonicity: 1, modulationIndex: 7,
                envelope: { attack: 0.01, decay: 0.4, sustain: 0.1, release: 1.4 },
                modulation: { type: "triangle" }
            }).connect(chorus);
            mainSynth.volume.value = -Infinity; // Empezar en silencio

            thiefSynth = new Tone.PolySynth(Tone.DuoSynth, {
                vibratoAmount: 0.5, vibratoRate: 5, harmonicity: 1,
                voice0: { volume: -8, portamento: 0, oscillator: { type: 'sawtooth' }, filterEnvelope: { attack: 0.01, decay: 0.5, sustain: 0.2, release: 1 }, envelope: { attack: 0.01, decay: 0.5, sustain: 0.2, release: 1 } },
                voice1: { volume: -15, portamento: 0, oscillator: { type: 'sine' }, filterEnvelope: { attack: 0.01, decay: 0.5, sustain: 0.2, release: 1 }, envelope: { attack: 0.01, decay: 0.5, sustain: 0.2, release: 1 } }
            }).connect(thiefReverb);
            thiefSynth.volume.value = -Infinity; // Empezar en silencio

            const mainNotes = [ { time: '0:0', notes: ['C4', 'E4', 'G4'] }, { time: '0:2', notes: ['A4'] }, { time: '1:0', notes: ['G3', 'B3', 'D4'] }, { time: '2:0', notes: ['F3', 'A3', 'C4'] }, { time: '2:2', notes: ['G3'] }, { time: '3:0', notes: ['E3', 'G3', 'B3'] }, { time: '4:0', notes: ['A3', 'C4', 'E4'] }, { time: '4:2', notes: ['B4'] }, { time: '5:0', notes: ['G3', 'B3', 'D4'] }, { time: '6:0', notes: ['C4', 'E4', 'A4'] }, { time: '6:2', notes: ['G4'] }, { time: '7:0', notes: ['F3', 'A3', 'C4'] } ];
            mainMusicLoop = new Tone.Part((time, value) => { mainSynth.triggerAttackRelease(value.notes, "2n", time); }, mainNotes);
            mainMusicLoop.loop = true; mainMusicLoop.loopEnd = '8m';
            mainMusicLoop.start(0); // Empezar el bucle (en silencio)
            
            const thiefNotes = [ { time: '0:0', notes: ['C2', 'D#2'], duration: '2n' }, { time: '1:0', notes: ['C#2', 'E2'], duration: '2n' }, { time: '2:0', notes: ['D2', 'F2'], duration: '1m' }, { time: '3:2', notes: ['B1', 'C2'], duration: '2n' } ];
            thiefMusicLoop = new Tone.Part((time, value) => { thiefSynth.triggerAttackRelease(value.notes, value.duration, time); }, thiefNotes);
            thiefMusicLoop.loop = true; thiefMusicLoop.loopEnd = '4m';
            thiefMusicLoop.start(0); // Empezar el bucle (en silencio)
        }

        function stopAllMusic() {
            if (!audioInitialized) return;
            
            // Simplemente bajar el volumen
             if (mainSynth) mainSynth.volume.rampTo(-Infinity, 0.5);
             if (thiefSynth) thiefSynth.volume.rampTo(-Infinity, 0.5);
        }

        function playMainMusic() {
            if (!audioInitialized || Tone.context.state !== 'running' || isMuted) return;
            
            // Transición suave (crossfade)
            mainSynth.volume.rampTo(-6, 1); // Subir volumen de la música principal
            thiefSynth.volume.rampTo(-Infinity, 1); // Bajar volumen del jefe
            
            if(gameState === 'PLAYING') {
                startRulesRotator(); 
            } else {
                 stopRulesRotator();
            }
        }

        function playThiefMusic() {
            if (!audioInitialized || Tone.context.state !== 'running' || isMuted) return;
            
             // Transición suave (crossfade)
            mainSynth.volume.rampTo(-Infinity, 1); // Bajar volumen de la música principal
            thiefSynth.volume.rampTo(-6, 1); // Subir volumen del jefe
            
            stopRulesRotator(); 
        }

        function startGameLoops() {
            if (animationFrameId || gameState !== 'PLAYING') return;
            
            stopGameLoops(); 
            
            if (!isWhispering) {
                startRulesRotator();
            }
            
            lastUpdateTime = 0; 
            animationFrameId = requestAnimationFrame(mainGameLoop);
            
            randomEventInterval = setInterval(triggerRandomEvent, 20000); 
        }
        
        function stopGameLoops() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
            
            clearInterval(randomEventInterval); 
            clearTimeout(wordDisplayTimeout);
            
            randomEventInterval = null; 
            lastUpdateTime = 0;
            
            stopRulesRotator(); 
        }
        
        async function startGameCommon(shouldLoad = true) {
             if (activeChallengeOnLoad) {
                handleChallengeFailure("Reto abandonado al recargar la página.");
                activeChallengeOnLoad = false;
             }
        }
        
        let audioInitHandlerAttached = false; 
        let audioInitAttempted = false; 

        function setupEventListeners() {
            document.getElementById('playButton').addEventListener('click', async () => {
                if (!audioInitialized) {
                    await initializeAudio(); 
                }
                if (Tone.context.state !== 'running') {
                    try {
                        await Tone.start();
                        console.log("Audio context started/resumed by Play button.");
                    } catch(e) {
                         console.error("Error starting/resuming audio context:", e);
                    }
                }
                
                // Mostrar modal de nombre en lugar de iniciar el juego
                document.getElementById('nameInputModal').classList.remove('hidden');
                document.getElementById('nameInputModal').classList.add('flex');
                document.getElementById('playerNameInput').focus();
            });

            // Nuevo listener para confirmar el nombre
            document.getElementById('confirmNameButton').addEventListener('click', () => {
                const nameInput = document.getElementById('playerNameInput');
                const nameError = document.getElementById('nameError');
                playerName = nameInput.value.trim();
                
                if (playerName === "") {
                    // Mostrar error y hacer vibrar el input
                    nameError.textContent = "¡Debes introducir un nombre!";
                    nameInput.classList.add('shake', 'border-red-500');
                    setTimeout(() => {
                        nameInput.classList.remove('shake', 'border-red-500');
                        nameError.textContent = ""; // Limpiar error
                    }, 500); // Duración de la animación
                    return; // No continuar
                }
                
                // Si hay nombre, continuar
                document.getElementById('nameInputModal').classList.add('hidden');
                document.getElementById('nameInputModal').classList.remove('flex');
                nameError.textContent = ""; // Limpiar error si lo hubiera

                // Ahora iniciar el juego
                startNewGame(); // Llama a la función que inicializa y cambia la vista
            });

            // Listener para 'Enter' en el input de nombre
            document.getElementById('playerNameInput').addEventListener('keyup', (e) => {
                if (e.key === 'Enter') {
                    document.getElementById('confirmNameButton').click();
                }
            });


            document.getElementById('buyButton').addEventListener('click', buyWord);
            
            document.getElementById('homeButton').addEventListener('click', () => {
                changeView('startup'); 
            });

            document.getElementById('modalCloseButton').addEventListener('click', () => {
                 const modal = document.getElementById('messageModal');
                 modal.classList.add('hidden');
                 modal.classList.remove('flex');
                 
                 // Revisado: Volver a PLAYING solo si estábamos en CINEMATIC
                if (gameState === 'CINEMATIC' && currentView === 'game') {
                     setGameState('PLAYING');
                }
            });
            
             document.getElementById('confirmYesButton').addEventListener('click', () => { 
                if (confirmCallback) confirmCallback(); 
                hideConfirmationModal(); 
            });
            document.getElementById('confirmNoButton').addEventListener('click', hideConfirmationModal); 
            
            document.getElementById('wordsModalCloseButton').addEventListener('click', () => {
                document.getElementById('wordsModal').classList.add('hidden');
                 // Volver a PLAYING si estábamos en cinemática
                if (gameState === 'CINEMATIC' && currentView === 'game') { 
                    setGameState('PLAYING');
                }
            });
            
            document.getElementById('backToGameFromGameOver').addEventListener('click', async () => {
                 // Volver a pedir nombre al reiniciar desde Game Over
                changeView('startup'); // Ir a inicio para mostrar modal
                document.getElementById('nameInputModal').classList.remove('hidden');
                document.getElementById('nameInputModal').classList.add('flex');
                document.getElementById('playerNameInput').value = ''; // Limpiar campo
                document.getElementById('playerNameInput').focus();
                // El juego se reiniciará al confirmar el nombre
            });
            document.getElementById('reiniciarButton').addEventListener('click', async () => {
                // Volver a pedir nombre al reiniciar desde Win Screen
                changeView('startup'); // Ir a inicio para mostrar modal
                document.getElementById('nameInputModal').classList.remove('hidden');
                document.getElementById('nameInputModal').classList.add('flex');
                document.getElementById('playerNameInput').value = ''; // Limpiar campo
                document.getElementById('playerNameInput').focus();
                // El juego se reiniciará al confirmar el nombre
            });

            document.getElementById('acceptGiftButton').addEventListener('click', () => {
                const modal = document.getElementById('guardianModal');
                modal.classList.add('opacity-0');
                setTimeout(() => {
                    modal.classList.add('hidden');
                    modal.classList.remove('flex');
                }, 300);

                let rewardMessage;
                if (consecutiveFailures === 0) {
                    playerMoney += 300000;
                    rewardMessage = "¡Don aceptado! Recibes 300,000 monedas y el LIMBO GRAMATICAL ha comenzado.";
                } else {
                    consecutiveFailures = 0;
                    rewardMessage = "¡Don aceptado! Tus vidas han sido restauradas y el LIMBO GRAMATICAL ha comenzado.";
                    updateUI(); // Actualizar UI para mostrar vidas restauradas
                }
                
                limboGramaticalEndTime = Date.now() + 60000; 
                
                showModal(rewardMessage); // showModal pondrá el estado en CINEMATIC y luego volverá a PLAYING
            });

            document.getElementById('rejectGiftButton').addEventListener('click', () => {
                const modal = document.getElementById('guardianModal');
                const dialogueEl = document.getElementById('guardianDialogue');
                const buttons = document.getElementById('guardianButtons');
                buttons.classList.add('hidden');

                typeEffect(dialogueEl, "Comprendo tu decisión. Que tu camino sea firme.", () => {
                    setTimeout(() => {
                        modal.classList.add('opacity-0');
                        setTimeout(() => {
                            modal.classList.add('hidden');
                            modal.classList.remove('flex');
                            setGameState('PLAYING');
                        }, 300);
                    }, 1500);
                });
            });

            document.getElementById('challengeInput').addEventListener('keyup', (e) => {
                if (e.key === 'Enter') endThiefMiniChallenge(e.target.value);
            });
            document.getElementById('trueButton').addEventListener('click', () => endThiefMiniChallenge(true));
            document.getElementById('falseButton').addEventListener('click', () => endThiefMiniChallenge(false));

            const muteButton = document.getElementById('muteButton');
            muteButton.innerHTML = ICON_LIBRARY.speakerOn;
            muteButton.addEventListener('click', async () => { 
                if (isMuted && !audioInitialized) {
                    await initializeAudio();
                     try {
                        await Tone.start();
                        console.log("Audio context started by Unmute button.");
                    } catch(e) {
                         console.error("Error starting audio context on unmute:", e);
                    }
                } else if (isMuted && audioInitialized && Tone.context.state !== 'running') {
                     try {
                        await Tone.start();
                        console.log("Audio context resumed by Unmute button.");
                    } catch(e) {
                         console.error("Error resuming audio context on unmute:", e);
                    }
                }

                isMuted = !isMuted;
                Tone.Destination.mute = isMuted; // Silencia o desilencia todo el audio
                muteButton.innerHTML = isMuted ? ICON_LIBRARY.speakerOff : ICON_LIBRARY.speakerOn;
            });
            
            window.addEventListener('beforeunload', () => {
            });

        }

        async function initGame() {
            changeView('startup'); 
            await initializeAudio(); 
            setupEventListeners();
        }
        
        window.onload = initGame;
    </script>
</body>
</html>
